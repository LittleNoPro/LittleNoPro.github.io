---
title: 'Dice CTF 2025'
date: 2025-05-30 21:00:00 +0700
categories: [ctf]
tags: [Crypto]
published: true
description: "Giải Dice CTF 2025"
---
# Write up DiceCTF 2025 Quals : Crypto

```
Author: Đặng Minh Tú
MSSV: 24520033
```

## vorpal-sword
### Challenge
Source code:
```python
#!/usr/local/bin/python

import secrets
from Crypto.PublicKey import RSA

DEATH_CAUSES = [
	'a fever',
	'dysentery',
	'measles',
	'cholera',
	'typhoid',
	'exhaustion',
	'a snakebite',
	'a broken leg',
	'a broken arm',
	'drowning',
]

def run_ot(key, msg0, msg1):
	'''
	https://en.wikipedia.org/wiki/Oblivious_transfer#1–2_oblivious_transfer
	'''
	x0 = secrets.randbelow(key.n)
	x1 = secrets.randbelow(key.n)
	print(f'n: {key.n}')
	print(f'e: {key.e}')
	print(f'x0: {x0}')
	print(f'x1: {x1}')
	v = int(input('v: '))
	assert 0 <= v < key.n, 'invalid value'
	k0 = pow(v - x0, key.d, key.n)
	k1 = pow(v - x1, key.d, key.n)
	m0 = int.from_bytes(msg0.encode(), 'big')
	m1 = int.from_bytes(msg1.encode(), 'big')
	c0 = (m0 + k0) % key.n
	c1 = (m1 + k1) % key.n
	print(f'c0: {c0}')
	print(f'c1: {c1}')

if __name__ == '__main__':
	with open('flag.txt') as f:
		flag = f.read().strip()

	print('=== CHOOSE YOUR OWN ADVENTURE: Vorpal Sword Edition ===')
	print('you enter a cave.')

	for _ in range(64):
		print('the tunnel forks ahead. do you take the left or right path?')
		key = RSA.generate(1024)
		msgs = [None, None]
		page = secrets.randbits(32)
		live = f'you continue walking. turn to page {page}.'
		die = f'you die of {secrets.choice(DEATH_CAUSES)}.'
		msgs = (live, die) if secrets.randbits(1) else (die, live)
		run_ot(key, *msgs)
		page_guess = int(input('turn to page: '))
		if page_guess != page:
			exit()

	print(f'you find a chest containing {flag}')
```

### Solution
Bài này người ta cho mình biết được `msg0 hoặc msg1` chính là 1 message được tạo bởi 1 trong các từ trong `DEATH_CAUSES`. Nên mình đã nghĩ đến việc làm thế nào đó để lợi dụng việc brute force 1 cái `msg` rồi từ đó tìm cái còn lại. Và đây là cách mình xử lý:

Ta có:
$$
\begin{cases}
c_0 = m_0 + k_0 \\
c_1 = m_1 + k_1
\end{cases}
$$

Giả sử $k_0 = -s * k_1$, khi đó:
\begin{gather}
c_0 + c_1 * s = (m_0+k_0) + (m_1+k_1)*s \\ = m_0 - s*k_1 + m_1*s+s*k_1 = m_0 + m_1 * s \pmod N
\end{gather}

Ta có thể thấy, nếu như ta biết được giá trị $s$ thì ta có thể tìm ra được $m_1$ hoặc $m_0$, vì ta đã biết giá trị của 1 trong 2 nên từ đó có thể tìm ra được giá trị còn lại. Bây giờ, phải gửi $v$ là gì để có thể nhận được phương trình trên ?

Ta có:
$$
\begin{cases}
k_0^e = v - x_0 \pmod N \\
k_1^e = v - x_1 \pmod N
\end{cases}
$$

\begin{gather}
\Rightarrow k_0^e = (-s * k_1)^e = (-s)^e*k_1^e = -s^e*(v-x_1) \pmod N \\
\Leftrightarrow -s^e*(v-x_1) = v-x_0 = -s^e*v+s^e*x_1\pmod N \\
\Leftrightarrow s^e*v+v=s^e*x_1+x_0 \pmod N \\
\Leftrightarrow v(s^e+1)=s^e*x_1+x_0 \pmod N \\
\Rightarrow v = \frac{x_0+s^e*x_1}{s^e + 1}
\end{gather}

**Note:** vì $e$ lẻ nên ta có $(-s)^e = -s^e$.

Vì các biến đổi trên đều là các biến đổi tương đương nên nếu ta gửi $v = \frac{x_0+s^e*x_1}{s^e + 1}$ thì ta sẽ có được $k_0 = -s*k_1$. Và giá trị $s$ của ta sẽ là một giá trị nào đó thỏa mãn điều kiện $(s^e+1, N) = 1$ để có nghịch đảo modulo (cái này ta có thể bruteforce để check).

Vậy ta đã có được biểu thức $c_0+c_1*s = m_0 + m_1*s \pmod N$ với các ẩn $c_0, c_1, s$ đã biết. Giờ ta sẽ xét 2 trường hợp:
- Nếu $m_0$ là tin nhắn `live = f'you continue walking. turn to page {page}.'` thì chứng tỏ $m_1$ là tin nhắn `die`. Từ đó, ta brute force $m_1$ rồi thay vào biểu thức và tìm $m_0$.
- Tương tự như trên.

Code:
```python
DEATH_CAUSES = [
	'a fever',
	'dysentery',
	'measles',
	'cholera',
	'typhoid',
	'exhaustion',
	'a snakebite',
	'a broken leg',
	'a broken arm',
	'drowning',
]

msgs = []
for cause in DEATH_CAUSES:
    die = f'you die of {cause}.'
    cur = int.from_bytes(die.encode(), 'big')
    msgs.append(cur)



from pwn import *
from sage.all import *
from Crypto.Util.number import long_to_bytes, bytes_to_long
from random import *

io = remote("dicec.tf", 31001)

for _ in range(64):
    io.recvuntil(b'n: ')
    n = int(io.recvuntil(b'\n').strip().decode())
    io.recvuntil(b'e: ')
    e = int(io.recvuntil(b'\n').strip().decode())
    io.recvuntil(b'x0: ')
    x0 = int(io.recvuntil(b'\n').strip().decode())
    io.recvuntil(b'x1: ')
    x1 = int(io.recvuntil(b'\n').strip().decode())

    for s in range(2, 100000):
        if gcd(pow(s, e, n) + 1, n) == 1:
            break

    v = (x0 + pow(s, e, n) * x1) * pow(1 + pow(s, e, n), -1, n) % n
    io.sendlineafter(b'v: ', str(v).encode())

    io.recvuntil(b'c0: ')
    c0 = int(io.recvuntil(b'\n').strip().decode())
    io.recvuntil(b'c1: ')
    c1 = int(io.recvuntil(b'\n').strip().decode())

    res = ""
    sum = (c0 + c1 * s) % n
    for m0 in msgs:
        if (sum - m0) % s != 0:
            continue
        m1 = (sum - m0) // s
        msg = long_to_bytes(m1)
        if b"you continue walking. turn to page " in msg and msg[35:-1].isdigit():
            res = msg
            break

    for m1 in msgs:
        m0 = (sum - s * m1) % n
        msg = long_to_bytes(m0)
        if b"you continue walking. turn to page " in msg and msg[35:-1].isdigit():
            res = msg
            break

    page = res[35:-1]
    io.sendlineafter(b'turn to page: ', page)

io.recvuntil(b'you find a chest containing ')
flag = io.recvline().strip().decode()
print(flag)

# Flag: dice{gl3am1ng_g0ld_doubl00n}
```