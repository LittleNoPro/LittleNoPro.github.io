---
title: 'Google CTF 2025'
date: 2025-06-28 00:00:00 +0700
categories: [CTF Write-up]
tags: [AES]
published: true
description: "Write-up for GoogleCTF 2025"
---

Vừa qua mình có tham gia giải Google CTF, đây là các bài mà mình đã làm được trong và sau giải.

## NUMEROLOGY

Source code:
```python
# Decompiled with PyLingual (https://pylingual.io)
# Internal filename: ./crypto_numerology.py
# Bytecode version: 3.12.0rc2 (3531)
# Source timestamp: 2025-06-06 16:54:22 UTC (1749228862)

import argparse
import json
import os
import struct
import sys
from pathlib import Path
CHACHA_CONSTANTS = (1634760805, 857760878, 2036477234, 1797285236)

def rotl32(v, c):
    """Rotate a 32-bit unsigned integer left by c bits."""  # inserted
    v &= 4294967295
    return v << c & 4294967295 | v >> 32 - c

def add32(a, b):
    """Add two 32-bit unsigned integers, wrapping modulo 2^32."""  # inserted
    return a + b & 4294967295

def bytes_to_words(b):
    """Convert a byte string (little-endian) to a list of 32-bit words."""  # inserted
    if len(b) % 4!= 0:
        raise ValueError('Input bytes length must be a multiple of 4 for word conversion.')
    return list(struct.unpack('<' + 'I' * (len(b) // 4), b))

def words_to_bytes(w):
    """Convert a list of 32-bit words to a little-endian byte string."""  # inserted
    return struct.pack('<' + 'I' * len(w), *w)

def mix_bits(state_list, a_idx, b_idx, c_idx, d_idx):
    """\n    Mixes Bits. Modifies state_list in-place.\n    """  # inserted
    a, b, c, d = (state_list[a_idx], state_list[b_idx], state_list[c_idx], state_list[d_idx])
    a = add32(a, b)
    d ^= a
    d = rotl32(d, 16)
    c = add32(c, d)
    b ^= c
    b = rotl32(b, 12)
    a = add32(a, b)
    d ^= a
    d = rotl32(d, 8)
    c = add32(c, d)
    b ^= c
    b = rotl32(b, 7)
    state_list[a_idx], state_list[b_idx], state_list[c_idx], state_list[d_idx] = (a, b, c, d)

def make_block(key_bytes, nonce_bytes, counter_int, current_constants_tuple, rounds_to_execute=8):
    """\n    Generates one 64-byte block of bits, allowing control over the\n    number of rounds executed.\n    """  # inserted
    if len(key_bytes)!= 32:
        raise ValueError('Key must be 32 bytes')
    if len(nonce_bytes)!= 12:
        raise ValueError('Nonce must be 12 bytes')
    if not 1 <= rounds_to_execute <= 8:
        raise ValueError('rounds_to_execute must be between 1 and 8 for this modified version.')
    state = [0] * 16
    state[0:4] = current_constants_tuple
    try:
        key_words = bytes_to_words(key_bytes)
        nonce_words = bytes_to_words(nonce_bytes)
    except ValueError as e:
        raise ValueError(f'Error converting key/nonce to words: {e}')
    state[4:12] = key_words
    state[12] = counter_int & 4294967295
    state[13:16] = nonce_words
    initial_state_snapshot = list(state)
    qr_operations_sequence = [
        lambda s: mix_bits(s, 0, 4, 8, 12),
        lambda s: mix_bits(s, 1, 5, 9, 13),
        lambda s: mix_bits(s, 2, 6, 10, 14),
        lambda s: mix_bits(s, 3, 7, 11, 15),
        lambda s: mix_bits(s, 0, 5, 10, 15),
        lambda s: mix_bits(s, 1, 6, 11, 12),
        lambda s: mix_bits(s, 2, 7, 8, 13),
        lambda s: mix_bits(s, 3, 4, 9, 14)
    ]
    for i in range(rounds_to_execute):
        qr_operations_sequence[i](state)
    for i in range(16):
        state[i] = add32(state[i], initial_state_snapshot[i])
    return words_to_bytes(state)
struct.zeros = (0, 0, 0, 0)

def get_bytes(key_bytes, nonce_bytes, initial_counter_int, data_bytes, current_constants_tuple, rounds_to_execute=8):
    """\n    Encrypts or decrypts data using a mysterious cipher.\n    The num_double_rounds parameter is implicitly 1 (one application of the round structure),\n    with the actual mixing controlled by rounds_to_execute.\n    """  # inserted
    output_byte_array = bytearray()
    current_counter = initial_counter_int & 4294967295
    data_len = len(data_bytes)
    block_idx = 0
    while block_idx < data_len:
        try:
            keystream_block = make_block(key_bytes, nonce_bytes, current_counter, current_constants_tuple, rounds_to_execute=rounds_to_execute)
        except Exception as e:
            raise Exception(f'Error in make_block during stream processing for counter {current_counter}: {e}')
        remaining_data_in_block = data_len - block_idx
        chunk_len = min(64, remaining_data_in_block)
        for i in range(chunk_len):
            output_byte_array.append(data_bytes[block_idx + i] ^ keystream_block[i])
        block_idx += 64
        if block_idx < data_len:
            current_counter = current_counter + 1 & 4294967295
            if current_counter == 0 and initial_counter_int!= 0 and (data_len > 64):
                print(f'Warning: counter for nonce {nonce_bytes.hex()} wrapped around to 0 during a multi-block message.')
    return bytes(output_byte_array)

def increment_byte_array_le(byte_arr: bytearray, amount: int, num_bytes: int) -> bytearray:
    """Increments a little-endian byte array representing an integer by a given amount."""  # inserted
    if len(byte_arr)!= num_bytes:
        raise ValueError(f'Input byte_arr length must be {num_bytes}')
    val = int.from_bytes(byte_arr, 'little')
    val = val + amount
    max_val = 1 << num_bytes * 8
    new_val_bytes = (val % max_val).to_bytes(num_bytes, 'little', signed=False)
    return bytearray(new_val_bytes)

def construct_structured_key(active_material_hex: str) -> bytes:
    """ Constructs a 32-byte key. If structured, uses 16 bytes of active material."""  # inserted
    key_words_int = [0] * 8
    if len(active_material_hex)!= 32:
        raise ValueError('For patterned keys (\'pattern_a\', \'pattern_b\'), active_material_hex must be 16 bytes (32 hex characters).')
    active_material_bytes = bytes.fromhex(active_material_hex)
    am_idx = 0

    def get_am_word():
        nonlocal am_idx  # inserted
        if am_idx + 4 > len(active_material_bytes):
            raise ValueError('Not enough active material for the 4 active key words.')
        word = int.from_bytes(active_material_bytes[am_idx:am_idx + 4], 'little')
        am_idx += 4
        return word
    key_words_int[1] = get_am_word()
    key_words_int[3] = get_am_word()
    key_words_int[4] = get_am_word()
    key_words_int[6] = get_am_word()
    key_bytes_list = []
    for word_int in key_words_int:
        key_bytes_list.append(word_int.to_bytes(4, 'little'))
    return b''.join(key_bytes_list)

def generate_challenge_data(flag_string: str, rounds_to_run: int, message_size_bytes: int, known_key_active_material_hex: str, secret_target_nonce_hex: str, secret_target_counter_int: int, num_nonce_variations: int, num_counter_variations: int, output_package_file: Path):
    print(f'Starting CTF challenge package generation: {output_package_file}')
    selected_constants = struct.zeros
    try:
        secret_target_nonce_bytes = bytes.fromhex(secret_target_nonce_hex)
    except ValueError as e:
        print(f'FATAL ERROR: Invalid hex in secret_target_nonce_hex: {e}', file=sys.stderr)
        sys.exit(1)
    known_structured_key_bytes = construct_structured_key(known_key_active_material_hex)
    known_structured_key_hex = known_structured_key_bytes.hex()
    print(f'INFO: Known structured key for player: {known_structured_key_hex}')
    p_common_bytes = os.urandom(message_size_bytes)
    p_common_hex = p_common_bytes.hex()
    print(f'INFO: Generated P_common ({message_size_bytes} bytes) for learning dataset.')
    learning_dataset_entries = []
    total_learning_samples = num_nonce_variations * num_counter_variations
    base_learning_nonce_suffix_start = bytearray([0] * 12)
    base_learning_counter_start = 0
    sample_count = 0
    for i in range(num_nonce_variations):
        nonce = 1 << i
        current_nonce_bytes = increment_byte_array_le(base_learning_nonce_suffix_start, nonce, 12)
        current_nonce_hex = bytes(current_nonce_bytes).hex()
        for j in range(num_counter_variations):
            counter = 1 << j
            current_counter_int = base_learning_counter_start + counter
            sample_id = f'sample_n{i}_c{j}'
            c_i_bytes = get_bytes(key_bytes=known_structured_key_bytes, nonce_bytes=bytes(current_nonce_bytes), initial_counter_int=current_counter_int, data_bytes=p_common_bytes, current_constants_tuple=selected_constants, rounds_to_execute=rounds_to_run)
            learning_dataset_entries.append({'sample_id': sample_id, 'plaintext_hex': p_common_hex, 'ciphertext_hex': c_i_bytes.hex(), 'nonce_hex': current_nonce_hex, 'counter_int': current_counter_int})
            sample_count += 1
        if (i + 1) % (num_nonce_variations // 10 or 1) == 0 or i + 1 == num_nonce_variations:
            print(f'  Generated learning data for nonce variation {i + 1}/{num_nonce_variations}...')

    print(f'Generated {sample_count} total learning samples.')
    p_secret_flag_bytes = flag_string.encode('utf-8')
    print(f'Encrypting the secret flag string (\'{flag_string[:20]}...\') with the KNOWN key using SECRET target_nonce/counter...')
    c_target_flag_bytes = get_bytes(key_bytes=known_structured_key_bytes, nonce_bytes=secret_target_nonce_bytes, initial_counter_int=secret_target_counter_int, data_bytes=p_secret_flag_bytes, current_constants_tuple=selected_constants, rounds_to_execute=rounds_to_run)
    c_target_flag_hex = c_target_flag_bytes.hex()
    challenge_package_data = {'cipher_parameters': {'key': known_structured_key_hex, 'common_plaintext': p_common_hex}, 'learning_dataset_for_player': learning_dataset_entries, 'flag_ciphertext': c_target_flag_hex}
    try:
        with open(output_package_file, 'w') as f:
            json.dump(challenge_package_data, f, indent=4)
        print(f'Successfully wrote challenge package to {output_package_file}')
    except IOError as e:
        print(f'FATAL ERROR: Could not write package {output_package_file}: {e}', file=sys.stderr)
        sys.exit(1)

    print('\nCTF Data generation complete.')

def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('--output_file', type=str, default='ctf_nc_recovery_pkg.json', help='Filename for the single JSON challenge package.')
    parser.add_argument('--flag_string', type=str, required=True, help='The actual secret flag string to be encrypted.')
    parser.add_argument('--rounds', type=int, default=1, help='Actual number of rounds to execute (1-8, default: 2 for a very weak variant).')
    parser.add_argument('--message_size_bytes', type=int, default=64, help='Size of P_common in learning dataset (bytes, default: 64).')
    parser.add_argument('--known_key_active_material_hex', type=str, required=True, help='Hex string for the non-zero part of the known key. ')
    parser.add_argument('--secret_target_nonce_hex', type=str, required=True, help='SECRET nonce (hex, 24 chars, first 4 hex chars/2 bytes must be \'0000\') to be recovered by player. Typically from set_secrets.sh.')
    parser.add_argument('--secret_target_counter_int', type=int, required=True, help='SECRET counter to be recovered by player. Typically from set_secrets.sh.')
    parser.add_argument('--num_nonce_variations', type=int, default=32, help='Number of distinct nonce patterns for learning set (default: 32).')
    parser.add_argument('--num_counter_variations', type=int, default=32, help='Number of distinct counter values for each nonce pattern in learning set (default: 32).')
    args = parser.parse_args()
    if not 1 <= args.rounds <= 8:
        print('ERROR: --rounds must be 1-8.', file=sys.stderr)
        sys.exit(1)
    try:
        bytes.fromhex(args.known_key_active_material_hex)
    except ValueError:
        print('ERROR: --known_key_active_material_hex invalid hex.', file=sys.stderr)
        sys.exit(1)
    if len(args.secret_target_nonce_hex)!= 24 or not args.secret_target_nonce_hex.startswith('0000'):
        print('ERROR: --secret_target_nonce_hex must be 24 hex chars and start with \'0000\'.', file=sys.stderr)
        sys.exit(1)
    try:
        bytes.fromhex(args.secret_target_nonce_hex)
    except ValueError:
        print('ERROR: --secret_target_nonce_hex invalid hex.', file=sys.stderr)
        sys.exit(1)
    if args.num_nonce_variations < 1 or args.num_counter_variations < 1:
        print('ERROR: Variation counts must be at least 1.', file=sys.stderr)
        sys.exit(1)
    if args.message_size_bytes < 1:
        print('ERROR: --message_size_bytes must be at least 1.', file=sys.stderr)
        sys.exit(1)
    output_package_file_path = Path(args.output_file)
    output_package_file_path.parent.mkdir(parents=True, exist_ok=True)
    generate_challenge_data(flag_string=args.flag_string, rounds_to_run=args.rounds, message_size_bytes=args.message_size_bytes, known_key_active_material_hex=args.known_key_active_material_hex, secret_target_nonce_hex=args.secret_target_nonce_hex, secret_target_counter_int=args.secret_target_counter_int, num_nonce_variations=args.num_nonce_variations, num_counter_variations=args.num_counter_variations, output_package_file=output_package_file_path)
if __name__ == '__main__':
    main()
```

file json:

```json
{
    "cipher_parameters": {
        "key": "000000005c5470020000000031f4727bf7d4923400000000e7bbb1c900000000",
        "common_plaintext": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392"
    },
    "learning_dataset_for_player": [
        {
            "sample_id": "sample_n0_c0",
            "plaintext_hex": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392",
            "ciphertext_hex": "d4922d0bae1521cffe67ab68fd132595c4942d350ff30c906325faca486555dc2ac805afddd31f16401ab7e1ebccdfc7e765f6a76746e822dd7002a2691f9392",
            "nonce_hex": "010000000000000000000000",
            "counter_int": 1
        },
        {
            "sample_id": "sample_n0_c1",
            "plaintext_hex": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392",
            "ciphertext_hex": "d4922d7bae1521cffe67ab68fd132595fcacadb20ff30c906325faca486555dc3ac806aeddd31f16401ab7e1ebccdfc79665f6a46746e822dd7002a2691f9392",
            "nonce_hex": "010000000000000000000000",
            "counter_int": 2
        },
        {
            "sample_id": "sample_n0_c2",
            "plaintext_hex": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392",
            "ciphertext_hex": "d4922d5bae1521cffe67ab68fd132595edbcadb30ff30c906325faca486555dc5ac800acddd31f16401ab7e1ebccdfc7a865f6a26746e822dd7002a2691f9392",
            "nonce_hex": "010000000000000000000000",
            "counter_int": 4
        },
        {
            "sample_id": "sample_n0_c3",
            "plaintext_hex": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392",
            "ciphertext_hex": "d4922d9bae1521cffe67ab68fd132595f3dcadb10ff30c906325faca486555dc9ac83ca8ddd31f16401ab7e1ebccdfc76c65f6ae6746e822dd7002a2691f9392",
            "nonce_hex": "010000000000000000000000",
            "counter_int": 8
        },
        ...
    ],
    "flag_ciphertext": "692f09e677335f6152655f67304e6e40141fa702e7e5b95b46756e63298d80a9bcbbd95465795f21ef0a"
}
```

Source code của bài nói về loại mã hóa `ChaCha20 Cipher`. Họ mã hóa cùng một plaintext nhưng với các `nonce, counter` khác nhau để lấy được các ciphertext khác nhau.

Như ta đã biết `ChaCha20` là một loại stream cipher, nôm na là kiểu mã hóa nãy sẽ sử dụng `key, nonce, counter` để mã hóa ra `keystream` sau đó tính `ciphertext = plaintext XOR keystream`.

Thì sau khi thử in ra và quan sát một số `keystream` của nhiều cặp trong file json thì mình nhận thấy được 1 điểm chung đáng ngờ đó là các `keystream` đều có dạng:
```
0 5d734ffd
1 00000000
2 00000000
3 00000000
4 62d7208e
5 b8a8e004
6 00000000
7 62e8e5f6
8 ea07e66c
9 00000000
10 ce776393
11 00000000
12 495f7302
13 00000000
14 00000000
15 00000024
```
Các words (1 words = 4 bytes) trong `keystream` mà bằng `0000` sẽ luôn cố định với mọi `keystream` khác nhau. Các `keystream` khác nhau chỉ khác ở các words có vị trí `0, 4, 5, 7, 8, 10, 12, 15`. Điều này xảy ra là do `key` của ta cũng có dạng tương tự như vậy, cũng có dạng là words 4 bytes nằm giữa các words `0000`. Cộng thêm việc trong source code có đề cập đến số rounds được sử dụng trong `Chacha` là:
```python
parser.add_argument('--rounds', type=int, default=1, help='Actual number of rounds to execute (1-8, default: 2 for a very weak variant).')
```

1 điều đáng lưu ý nữa đó là `flag_ciphertext` của ta có 11 words. Tức là ta chỉ cần tìm 11 words đầu tiên của `keystream` thôi là đủ để giải mã rồi.

Ta thấy rằng, nếu như `rounds=1` thì `qr_operations_sequence` sẽ chỉ thực hiện được bước đầu tiên đó là `mix_bits(s, 0, 4, 8, 12)`. Sau đó add từng trạng thái với mỗi trạng thái trước thay đổi của nó.

Vì đã biết `key`, ta có thể tạo lại được mảng `state` ban đầu sẽ luôn luôn có dạng là: `[0, 0, 0, 0, 0, 40916060, 0, 2071131185, 882038007, 0, 3383868391, 0, 0, 0, 0, 0]` với `state[12]` được tính dựa trên `counter` còn 3 `state` cuối được tính dựa trên `nonce`. Từ 3 giá trị `state[0], state[4], state[8]` trước khi `mix` và `state[0] = xor(b'CTF{', flag_ciphertext[:4])` sau khi `mix` đã biết, ta hoàn toàn có thể reverse đoạn code trong hàm `mix_bits` để tìm được `state[12]` ban đầu (viết lại hàm `rotr32, sub32`).
```python
a = xor(b'CTF{', flag_ciphertext[:4])
a = bytes_to_words(a)  # 2639231786
a = 2639231786
b = a
b = rotr32(b, 12)
c = b
d = sub32(c, 882038007)
d = rotr32(d, 16)
counter_int = d
```

Sau khi tìm được `counter` rồi thì đưa nó vào lại hàm `get_bytes` để mã hóa `keystream`, rồi lấy 11 words đầu tiên để giải mã và lấy flag.

Code solve:
```python
import argparse
import json
import os
import struct
import sys
from pathlib import Path
from pwn import xor
CHACHA_CONSTANTS = (1634760805, 857760878, 2036477234, 1797285236)

def rotr32(v, c):
    v &= 0xffffffff
    return ((v >> c) | (v << (32 - c))) & 0xffffffff

def sub32(a, b):
    return (a - b) & 0xffffffff

def rotl32(v, c):
    """Rotate a 32-bit unsigned integer left by c bits."""  # inserted
    v &= 4294967295
    return v << c & 4294967295 | v >> 32 - c

def add32(a, b):
    """Add two 32-bit unsigned integers, wrapping modulo 2^32."""  # inserted
    return a + b & 4294967295

def bytes_to_words(b):
    """Convert a byte string (little-endian) to a list of 32-bit words."""  # inserted
    if len(b) % 4!= 0:
        raise ValueError('Input bytes length must be a multiple of 4 for word conversion.')
    return list(struct.unpack('<' + 'I' * (len(b) // 4), b))

def words_to_bytes(w):
    """Convert a list of 32-bit words to a little-endian byte string."""  # inserted
    return struct.pack('<' + 'I' * len(w), *w)

def mix_bits(state_list, a_idx, b_idx, c_idx, d_idx):
    """\n    Mixes Bits. Modifies state_list in-place.\n    """  # inserted
    a, b, c, d = (state_list[a_idx], state_list[b_idx], state_list[c_idx], state_list[d_idx])
    a = add32(a, b)
    d ^= a
    d = rotl32(d, 16)
    c = add32(c, d)
    b ^= c
    b = rotl32(b, 12)
    a = add32(a, b)
    d ^= a
    d = rotl32(d, 8)
    c = add32(c, d)
    b ^= c
    b = rotl32(b, 7)
    state_list[a_idx], state_list[b_idx], state_list[c_idx], state_list[d_idx] = (a, b, c, d)

def make_block(key_bytes, nonce_bytes, counter_int, current_constants_tuple, rounds_to_execute=8):
    """\n    Generates one 64-byte block of bits, allowing control over the\n    number of rounds executed.\n    """  # inserted
    if len(key_bytes)!= 32:
        raise ValueError('Key must be 32 bytes')
    if len(nonce_bytes)!= 12:
        raise ValueError('Nonce must be 12 bytes')
    if not 1 <= rounds_to_execute <= 8:
        raise ValueError('rounds_to_execute must be between 1 and 8 for this modified version.')
    state = [0] * 16
    state[0:4] = current_constants_tuple
    try:
        key_words = bytes_to_words(key_bytes)
        nonce_words = bytes_to_words(nonce_bytes)
    except ValueError as e:
        raise ValueError(f'Error converting key/nonce to words: {e}')
    state[4:12] = key_words
    state[12] = counter_int & 4294967295
    state[13:16] = nonce_words
    initial_state_snapshot = list(state)
    qr_operations_sequence = [
        lambda s: mix_bits(s, 0, 4, 8, 12),
        lambda s: mix_bits(s, 1, 5, 9, 13),
        lambda s: mix_bits(s, 2, 6, 10, 14),
        lambda s: mix_bits(s, 3, 7, 11, 15),
        lambda s: mix_bits(s, 0, 5, 10, 15),
        lambda s: mix_bits(s, 1, 6, 11, 12),
        lambda s: mix_bits(s, 2, 7, 8, 13),
        lambda s: mix_bits(s, 3, 4, 9, 14)
    ]
    for i in range(rounds_to_execute):
        qr_operations_sequence[i](state)
    for i in range(16):
        state[i] = add32(state[i], initial_state_snapshot[i])
    return words_to_bytes(state)
struct.zeros = (0, 0, 0, 0)

def get_bytes(key_bytes, nonce_bytes, initial_counter_int, data_bytes, current_constants_tuple, rounds_to_execute=8):
    """\n    Encrypts or decrypts data using a mysterious cipher.\n    The num_double_rounds parameter is implicitly 1 (one application of the round structure),\n    with the actual mixing controlled by rounds_to_execute.\n    """  # inserted
    output_byte_array = bytearray()
    current_counter = initial_counter_int & 4294967295
    data_len = len(data_bytes)
    block_idx = 0
    while block_idx < data_len:
        try:
            keystream_block = make_block(key_bytes, nonce_bytes, current_counter, current_constants_tuple, rounds_to_execute=rounds_to_execute)
        except Exception as e:
            raise Exception(f'Error in make_block during stream processing for counter {current_counter}: {e}')
        remaining_data_in_block = data_len - block_idx
        chunk_len = min(64, remaining_data_in_block)
        for i in range(chunk_len):
            output_byte_array.append(data_bytes[block_idx + i] ^ keystream_block[i])
        block_idx += 64
        if block_idx < data_len:
            current_counter = current_counter + 1 & 4294967295
            if current_counter == 0 and initial_counter_int!= 0 and (data_len > 64):
                print(f'Warning: counter for nonce {nonce_bytes.hex()} wrapped around to 0 during a multi-block message.')
    return bytes(output_byte_array)

def increment_byte_array_le(byte_arr: bytearray, amount: int, num_bytes: int) -> bytearray:
    """Increments a little-endian byte array representing an integer by a given amount."""  # inserted
    if len(byte_arr)!= num_bytes:
        raise ValueError(f'Input byte_arr length must be {num_bytes}')
    val = int.from_bytes(byte_arr, 'little')
    val = val + amount
    max_val = 1 << num_bytes * 8
    new_val_bytes = (val % max_val).to_bytes(num_bytes, 'little', signed=False)
    return bytearray(new_val_bytes)


key = "000000005c5470020000000031f4727bf7d4923400000000e7bbb1c900000000"
key = bytes.fromhex(key)
flag_ciphertext = "692f09e677335f6152655f67304e6e40141fa702e7e5b95b46756e63298d80a9bcbbd95465795f21ef0a"
flag_ciphertext = bytes.fromhex(flag_ciphertext)

a = xor(b'CTF{', flag_ciphertext[:4])
a = bytes_to_words(a)
a = 2639231786
b = a
b = rotr32(b, 12)
c = b
d = sub32(c, 882038007)
d = rotr32(d, 16)
counter_int = d

selected_constants = struct.zeros
known_structured_key_bytes = key

state = [0] * 16
state[0:4] = selected_constants
state[4:12] = bytes_to_words(key)

flag = get_bytes(known_structured_key_bytes, b'\x00'*12, counter_int, flag_ciphertext, selected_constants, rounds_to_execute=1)
print(flag)

# CTF{w3_aRe_g0Nn@_ge7_MY_FuncKee_monkey_!!}
```




## FILTERMAZE
Source code:
```python
# filtermaze.py
import json
import secrets
import sys
from dataclasses import asdict, dataclass, field
from typing import List

import numpy as np

# This is a placeholder path for local testing.
# On the real server, this will be a secret, longer path.
SECRET_HAMILTONIAN_PATH = [0]


@dataclass
class LWEParams:
  lwe_n: int = 50
  lwe_m: int = 100
  lwe_q: int = 1009
  A: List[int] = field(init=False)
  s: List[int] = field(init=False)
  e: List[int] = field(init=False)
  b: List[int] = field(init=False)

  def __post_init__(self):
    self.lwe_error_range = [secrets.randbelow(self.lwe_q) for _ in range(self.lwe_m)]


def load_graph(filepath):
  with open(filepath, "r") as f:
    graph_data = json.load(f)
  return {int(k): v for k, v in graph_data.items()}


def load_flag(filepath):
  with open(filepath, "r") as f:
    flag = f.readline().strip()
  return flag


def create_lwe_instance_with_error(n, m, q, error_mags):
  s = np.array([secrets.randbelow(q) for _ in range(n)], dtype=int)
  A = np.random.randint(0, q, size=(m, n), dtype=int)  # Public matrix
  e = np.array([secrets.choice([-mag, +mag]) for mag in error_mags], dtype=int)
  b = (A @ s + e) % q
  return A.tolist(), s.tolist(), e.tolist(), b.tolist()


class PathChecker:
  def __init__(
    self,
    secret_path,
    graph_data,
    lwe_error_mags,
  ):
    self.secret_path = secret_path
    self.graph = graph_data
    self.lwe_error_mags = lwe_error_mags
    self.path_len = len(self.secret_path)

  def check(self, candidate_segment):
    seg_len = len(candidate_segment)
    if seg_len > self.path_len:
      return False
    for i, node in enumerate(candidate_segment):
      if node != self.secret_path[i]:  # Node mismatch
        return False

      if i > 0:
        prev_node = candidate_segment[i - 1]
        neighbors = self.graph.get(prev_node)
        if neighbors is None or node not in neighbors:
          return False

    if seg_len == self.path_len:
      error_magnitudes = [int(abs(err_val)) for err_val in self.lwe_error_mags]
      return error_magnitudes
    else:
      return True


def main():
  flag = load_flag("flag")
  graph_data = load_graph("graph.json")
  lwe_params = LWEParams()
  if len(sys.argv) > 1:
    if sys.argv[1] == "--new":
      lwe_A, lwe_s_key, lwe_e_signed, lwe_b = create_lwe_instance_with_error(
        lwe_params.lwe_n, lwe_params.lwe_m, lwe_params.lwe_q, lwe_params.lwe_error_range
      )
      lwe_params.A = lwe_A
      lwe_params.b = lwe_b
      lwe_params.s = lwe_s_key
      lwe_params.e = lwe_e_signed
      with open("lwe_secret_params.json", "w") as s:
        json.dump(asdict(lwe_params), s, indent=2)
  else:
    with open("lwe_secret_params.json", "r") as s:
      lwe_params = json.load(s)
    lwe_A = lwe_params.get("A")
    lwe_s_key = lwe_params.get("s")
    lwe_e_signed = lwe_params.get("e")
    lwe_b = lwe_params.get("b")

  path_checker = PathChecker(
    secret_path=SECRET_HAMILTONIAN_PATH,
    graph_data=graph_data,
    lwe_error_mags=lwe_e_signed,
  )

  initial_messages = [
    "Welcome! I've hidden the key at the end of the maze. You can use this to open the chest to get the flag.",
    'Commands: {"command": "check_path", "segment": [...]}',
    '          {"command": "get_flag", "lwe_secret_s": [...] }',
  ]
  for msg in initial_messages:
    print(msg, flush=True)

  for line in sys.stdin:
    data_str = line.strip()
    if not data_str:
      continue

    response_payload = {}
    try:
      client_command = json.loads(data_str)
      command = client_command.get("command")

      if command == "check_path":
        segment = client_command.get("segment")
        if not isinstance(segment, list):
          raise TypeError("Segment must be a list.")
        path_result = path_checker.check(segment)

        if isinstance(path_result, list):
          response_payload = {
            "status": "path_complete",
            "lwe_error_magnitudes": path_result,
          }
        elif path_result is True:
          response_payload = {"status": "valid_prefix"}
        else:
          response_payload = {"status": "path_incorrect"}
      elif command == "get_flag":
        key_s_raw = client_command.get("lwe_secret_s")
        if not isinstance(key_s_raw, list):
          raise TypeError("lwe_secret_s must be a list.")

        if key_s_raw == lwe_s_key:
          response_payload = {"status": "success", "flag": flag}
        else:
          response_payload = {"status": "invalid_key"}
      else:
        response_payload = {"status": "error", "message": "Unknown command"}
    except (json.JSONDecodeError, ValueError, TypeError) as e:
      json_err = f"Invalid format or data: {e}"
      response_payload = {
        "status": "error",
        "message": json_err,
      }
    except Exception as e_cmd:
      err_mesg = f"Error processing command '{data_str}': {e_cmd}"
      response_payload = {"status": "error", "message": err_mesg}

    print(json.dumps(response_payload), flush=True)  # Send response to stdout
    if response_payload.get("flag"):
      break


if __name__ == "__main__":
  main()
```

### Part 1:
Ta được cung cấp cho một đố thị gồm 30 đỉnh, mục đích là làm thế nào để ta có thể tìm ra được `Hamilton path` của server. Bài toán tìm đường đi Hamilton là bài toán `NP-Complete`, nếu như ta muốn tìm hết tất cả các đường đi Hamilton của đồ thị thì độ phức tạp rất lớn `O(N!)` hoặc `O(N^2*2^N)`. Không thể tìm như vậy trong bài này vì `N = 30`. Mình đọc tiếp trong source code thì phát hiện ra:
```python
elif path_result is True:
    response_payload = {"status": "valid_prefix"}
```
Server có thể cho ta biết đường đi Hamilton của ta trùng với prefix đường đi của server. Từ đó ta có thể dễ dàng bruteforce từng đỉnh của đường đi.

### Part 2:
Sau khi tìm được đường đi đúng rồi, server trả cho ta một list `lwe_error_magnitudes`. Đây chính là **giá trị tuyệt đối** của vector `e` được sinh ra trong hàm `create_lwe_instance_with_error`.

Ý nghĩa của hàm `create_lwe_instance_with_error` là tính:

$$
A * s + e = b \pmod q
$$

Với ma trận $A$, vector $b$, vector $\mid e \mid$, số nguyên $q$ đã biết. Việc của ta là tìm vector $s$ để lấy flag. Ta có phương trình dưới dạng từng hàng của ma trận:

$$
\begin{cases}
a_1s+e_1=b_{1}\pmod q\\
a_2s+e_2=b_{2}\pmod q\\
\vdots\\
a_ms+e_m=b_{m}\pmod q
\end{cases}

<=>

\begin{cases}
\frac{a_1}{|e_1|}s + \frac{e_1}{|e_1|} = \frac{b_1}{|e_1|} \pmod q \\
\frac{a_2}{|e_2|}s + \frac{e_2}{|e_2|} = \frac{b_2}{|e_2|} \pmod q \\
\vdots \\
\frac{a_m}{|e_m|}s + \frac{e_m}{|e_m|} = \frac{b_m}{|e_m|} \pmod q \\
\end{cases}

<=>

\begin{cases}
\frac{a_1}{|e_1|}s + k_1q = \frac{b_1}{|e_1|} - \frac{e_1}{|e_1|} \\
\frac{a_2}{|e_2|}s + k_2q = \frac{b_2}{|e_2|} - \frac{e_2}{|e_2|} \\
\vdots \\
\frac{a_m}{|e_m|}s + k_mq = \frac{b_m}{|e_m|} - \frac{e_m}{|e_m|} \\
\end{cases}
$$

Gọi `A', b'` là ma trận và vector sau khi chia cho `|e|`.
Mô phỏng bằng phép nhân ma trận:

$$
\left[\begin{array}{cccccccc}
a'_{11} & a'_{12} & \cdots & a'_{1n} & q & 0 & \cdots & 0\\
a'_{21} & \ddots &  & \vdots & 0 & q &  & \vdots\\
\vdots &  & \ddots & \vdots & \vdots &  & \ddots & \vdots\\
a'_{m1} & \cdots & \cdots & a'_{mn} & 0 & \cdots & \cdots & q
\end{array}\right]\left[\begin{array}{c}
s_{1}\\
\vdots\\
s_{n}\\
k_{1}\\
\vdots\\
k_{m}
\end{array}\right]=b'-e'
$$

Tương đương:

$$
s_{1}\left[\begin{array}{c}
a'_{11}\\
a'_{21}\\
\vdots\\
a'_{m1}
\end{array}\right]+\cdots+s_{n}\left[\begin{array}{c}
a'_{1n}\\
a'_{2}\\
\vdots\\
a'_{mn}
\end{array}\right]+k_{1}\left[\begin{array}{c}
q\\
0\\
\vdots\\
0
\end{array}\right]+k_{2}\left[\begin{array}{c}
0\\
q\\
\vdots\\
0
\end{array}\right]+\cdots+k_{m}\left[\begin{array}{c}
0\\
0\\
\vdots\\
q
\end{array}\right]=b'-e'
$$

Ta biết rằng, vector $\frac{e}{\mid e \mid}$ sẽ là một vector chỉ chứa các hệ số là $0, 1, -1$ (rất nhỏ). Nhờ điều đó, bài toán trở thành tìm vector gần vector $b'$ nhất (CVP). Sử dụng LLL và [Thuật toán BaiBai](https://eprint.iacr.org/2023/032.pdf) để giải quyết. Sau khi tìm được vector $t$ gần vector $b$ nhất rồi, ta đã có $As \approx t$, thì dùng hàm `solve_right()` có sẵn trong `sage` để tìm lại vector `s`.

Code:
```python
from pwn import *
import subprocess
import re
import tempfile
import os
import json
from sage.all import *
from sage.modules.free_module_integer import IntegerLattice
import json

p = remote("filtermaze.2025.ctfcompetition.com", 1337, level='debug')

pow_prompt = p.recvuntil(b"Solution?").decode()
challenge_id = re.search(r"solve (s\.[^\s]+)", pow_prompt).group(1)
with tempfile.NamedTemporaryFile("w+", delete=False) as tmpf:
    tmpf.write(subprocess.check_output(["curl", "-sSL", "https://goo.gle/kctf-pow"]).decode())
    tmpf.flush()
    pow_script_path = tmpf.name
solution = subprocess.check_output(["python3", pow_script_path, "solve", challenge_id]).strip()
p.sendline(solution)
p.recvuntil(b'[...] }\n')


path, e = [], []
for _ in range(30):
    for node in range(30):
        if node in path:
            continue
        path.append(node)
        payload = {"command": "check_path", "segment": path}
        p.sendline(json.dumps(payload))
        response = p.recvline().decode().strip()

        if 'path_complete' in response:
            e = json.loads(response)['lwe_error_magnitudes']
            break

        if 'valid_prefix' in response:
            break
        else:
            path.pop()

n, m, q = 50, 100, 1009
def Babai_closest_vector(M, G, target):
    small = target
    for _ in range(1):
        for i in reversed(range(M.nrows())):
            c = ((small * G[i]) / (G[i] * G[i])).round()
            small -= M[i] * c
    return target - small


with open("/home/team/CodePy/GoogleCTF2025/crypto-filtermaze/lwe_pub_params.json", "r") as f:
    data = json.load(f)
    A = Matrix(GF(q), m, n, data["A"])
    b = list(vector(GF(q), data["b"]))

e = vector(GF(q), e)
M = Matrix(ZZ, m + n, m)
for i in range(m):
    M[i, i] = q
    b[i] = b[i] / e[i]
for x in range(m):
    for y in range(n):
        A[x, y] = A[x, y] / e[x]
        M[m + y, x] = int(A[x, y])

lattice = IntegerLattice(M, lll_reduce=True)
gram = lattice.reduced_basis.gram_schmidt()[0]
target = vector(ZZ, b)
res = Babai_closest_vector(lattice.reduced_basis, gram, target)
s = A.solve_right(vector(GF(q), res))

p.sendline(json.dumps({"command": "get_flag", "lwe_secret_s": [int(x) for x in s]}))
flag = p.recvline().decode().strip()
print(flag)

os.remove(pow_script_path)

# CTF{d4_sup3r_sh0rt_3rr0r_v3ct0r_1s_th3_k3y}
```

## Continue ...