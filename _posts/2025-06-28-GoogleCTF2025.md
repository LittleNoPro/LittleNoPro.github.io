---
title: 'Google CTF 2025'
date: 2025-06-28 00:00:00 +0700
categories: [CTF Write-up]
tags: [AES]
published: true
description: "Write-up for GoogleCTF 2025"
---

V·ª´a qua m√¨nh c√≥ tham gia gi·∫£i Google CTF, ƒë√¢y l√† c√°c b√†i m√† m√¨nh ƒë√£ l√†m ƒë∆∞·ª£c trong v√† sau gi·∫£i.

## NUMEROLOGY

Source code:
```python
# Decompiled with PyLingual (https://pylingual.io)
# Internal filename: ./crypto_numerology.py
# Bytecode version: 3.12.0rc2 (3531)
# Source timestamp: 2025-06-06 16:54:22 UTC (1749228862)

import argparse
import json
import os
import struct
import sys
from pathlib import Path
CHACHA_CONSTANTS = (1634760805, 857760878, 2036477234, 1797285236)

def rotl32(v, c):
    """Rotate a 32-bit unsigned integer left by c bits."""  # inserted
    v &= 4294967295
    return v << c & 4294967295 | v >> 32 - c

def add32(a, b):
    """Add two 32-bit unsigned integers, wrapping modulo 2^32."""  # inserted
    return a + b & 4294967295

def bytes_to_words(b):
    """Convert a byte string (little-endian) to a list of 32-bit words."""  # inserted
    if len(b) % 4!= 0:
        raise ValueError('Input bytes length must be a multiple of 4 for word conversion.')
    return list(struct.unpack('<' + 'I' * (len(b) // 4), b))

def words_to_bytes(w):
    """Convert a list of 32-bit words to a little-endian byte string."""  # inserted
    return struct.pack('<' + 'I' * len(w), *w)

def mix_bits(state_list, a_idx, b_idx, c_idx, d_idx):
    """\n    Mixes Bits. Modifies state_list in-place.\n    """  # inserted
    a, b, c, d = (state_list[a_idx], state_list[b_idx], state_list[c_idx], state_list[d_idx])
    a = add32(a, b)
    d ^= a
    d = rotl32(d, 16)
    c = add32(c, d)
    b ^= c
    b = rotl32(b, 12)
    a = add32(a, b)
    d ^= a
    d = rotl32(d, 8)
    c = add32(c, d)
    b ^= c
    b = rotl32(b, 7)
    state_list[a_idx], state_list[b_idx], state_list[c_idx], state_list[d_idx] = (a, b, c, d)

def make_block(key_bytes, nonce_bytes, counter_int, current_constants_tuple, rounds_to_execute=8):
    """\n    Generates one 64-byte block of bits, allowing control over the\n    number of rounds executed.\n    """  # inserted
    if len(key_bytes)!= 32:
        raise ValueError('Key must be 32 bytes')
    if len(nonce_bytes)!= 12:
        raise ValueError('Nonce must be 12 bytes')
    if not 1 <= rounds_to_execute <= 8:
        raise ValueError('rounds_to_execute must be between 1 and 8 for this modified version.')
    state = [0] * 16
    state[0:4] = current_constants_tuple
    try:
        key_words = bytes_to_words(key_bytes)
        nonce_words = bytes_to_words(nonce_bytes)
    except ValueError as e:
        raise ValueError(f'Error converting key/nonce to words: {e}')
    state[4:12] = key_words
    state[12] = counter_int & 4294967295
    state[13:16] = nonce_words
    initial_state_snapshot = list(state)
    qr_operations_sequence = [
        lambda s: mix_bits(s, 0, 4, 8, 12),
        lambda s: mix_bits(s, 1, 5, 9, 13),
        lambda s: mix_bits(s, 2, 6, 10, 14),
        lambda s: mix_bits(s, 3, 7, 11, 15),
        lambda s: mix_bits(s, 0, 5, 10, 15),
        lambda s: mix_bits(s, 1, 6, 11, 12),
        lambda s: mix_bits(s, 2, 7, 8, 13),
        lambda s: mix_bits(s, 3, 4, 9, 14)
    ]
    for i in range(rounds_to_execute):
        qr_operations_sequence[i](state)
    for i in range(16):
        state[i] = add32(state[i], initial_state_snapshot[i])
    return words_to_bytes(state)
struct.zeros = (0, 0, 0, 0)

def get_bytes(key_bytes, nonce_bytes, initial_counter_int, data_bytes, current_constants_tuple, rounds_to_execute=8):
    """\n    Encrypts or decrypts data using a mysterious cipher.\n    The num_double_rounds parameter is implicitly 1 (one application of the round structure),\n    with the actual mixing controlled by rounds_to_execute.\n    """  # inserted
    output_byte_array = bytearray()
    current_counter = initial_counter_int & 4294967295
    data_len = len(data_bytes)
    block_idx = 0
    while block_idx < data_len:
        try:
            keystream_block = make_block(key_bytes, nonce_bytes, current_counter, current_constants_tuple, rounds_to_execute=rounds_to_execute)
        except Exception as e:
            raise Exception(f'Error in make_block during stream processing for counter {current_counter}: {e}')
        remaining_data_in_block = data_len - block_idx
        chunk_len = min(64, remaining_data_in_block)
        for i in range(chunk_len):
            output_byte_array.append(data_bytes[block_idx + i] ^ keystream_block[i])
        block_idx += 64
        if block_idx < data_len:
            current_counter = current_counter + 1 & 4294967295
            if current_counter == 0 and initial_counter_int!= 0 and (data_len > 64):
                print(f'Warning: counter for nonce {nonce_bytes.hex()} wrapped around to 0 during a multi-block message.')
    return bytes(output_byte_array)

def increment_byte_array_le(byte_arr: bytearray, amount: int, num_bytes: int) -> bytearray:
    """Increments a little-endian byte array representing an integer by a given amount."""  # inserted
    if len(byte_arr)!= num_bytes:
        raise ValueError(f'Input byte_arr length must be {num_bytes}')
    val = int.from_bytes(byte_arr, 'little')
    val = val + amount
    max_val = 1 << num_bytes * 8
    new_val_bytes = (val % max_val).to_bytes(num_bytes, 'little', signed=False)
    return bytearray(new_val_bytes)

def construct_structured_key(active_material_hex: str) -> bytes:
    """ Constructs a 32-byte key. If structured, uses 16 bytes of active material."""  # inserted
    key_words_int = [0] * 8
    if len(active_material_hex)!= 32:
        raise ValueError('For patterned keys (\'pattern_a\', \'pattern_b\'), active_material_hex must be 16 bytes (32 hex characters).')
    active_material_bytes = bytes.fromhex(active_material_hex)
    am_idx = 0

    def get_am_word():
        nonlocal am_idx  # inserted
        if am_idx + 4 > len(active_material_bytes):
            raise ValueError('Not enough active material for the 4 active key words.')
        word = int.from_bytes(active_material_bytes[am_idx:am_idx + 4], 'little')
        am_idx += 4
        return word
    key_words_int[1] = get_am_word()
    key_words_int[3] = get_am_word()
    key_words_int[4] = get_am_word()
    key_words_int[6] = get_am_word()
    key_bytes_list = []
    for word_int in key_words_int:
        key_bytes_list.append(word_int.to_bytes(4, 'little'))
    return b''.join(key_bytes_list)

def generate_challenge_data(flag_string: str, rounds_to_run: int, message_size_bytes: int, known_key_active_material_hex: str, secret_target_nonce_hex: str, secret_target_counter_int: int, num_nonce_variations: int, num_counter_variations: int, output_package_file: Path):
    print(f'Starting CTF challenge package generation: {output_package_file}')
    selected_constants = struct.zeros
    try:
        secret_target_nonce_bytes = bytes.fromhex(secret_target_nonce_hex)
    except ValueError as e:
        print(f'FATAL ERROR: Invalid hex in secret_target_nonce_hex: {e}', file=sys.stderr)
        sys.exit(1)
    known_structured_key_bytes = construct_structured_key(known_key_active_material_hex)
    known_structured_key_hex = known_structured_key_bytes.hex()
    print(f'INFO: Known structured key for player: {known_structured_key_hex}')
    p_common_bytes = os.urandom(message_size_bytes)
    p_common_hex = p_common_bytes.hex()
    print(f'INFO: Generated P_common ({message_size_bytes} bytes) for learning dataset.')
    learning_dataset_entries = []
    total_learning_samples = num_nonce_variations * num_counter_variations
    base_learning_nonce_suffix_start = bytearray([0] * 12)
    base_learning_counter_start = 0
    sample_count = 0
    for i in range(num_nonce_variations):
        nonce = 1 << i
        current_nonce_bytes = increment_byte_array_le(base_learning_nonce_suffix_start, nonce, 12)
        current_nonce_hex = bytes(current_nonce_bytes).hex()
        for j in range(num_counter_variations):
            counter = 1 << j
            current_counter_int = base_learning_counter_start + counter
            sample_id = f'sample_n{i}_c{j}'
            c_i_bytes = get_bytes(key_bytes=known_structured_key_bytes, nonce_bytes=bytes(current_nonce_bytes), initial_counter_int=current_counter_int, data_bytes=p_common_bytes, current_constants_tuple=selected_constants, rounds_to_execute=rounds_to_run)
            learning_dataset_entries.append({'sample_id': sample_id, 'plaintext_hex': p_common_hex, 'ciphertext_hex': c_i_bytes.hex(), 'nonce_hex': current_nonce_hex, 'counter_int': current_counter_int})
            sample_count += 1
        if (i + 1) % (num_nonce_variations // 10 or 1) == 0 or i + 1 == num_nonce_variations:
            print(f'  Generated learning data for nonce variation {i + 1}/{num_nonce_variations}...')

    print(f'Generated {sample_count} total learning samples.')
    p_secret_flag_bytes = flag_string.encode('utf-8')
    print(f'Encrypting the secret flag string (\'{flag_string[:20]}...\') with the KNOWN key using SECRET target_nonce/counter...')
    c_target_flag_bytes = get_bytes(key_bytes=known_structured_key_bytes, nonce_bytes=secret_target_nonce_bytes, initial_counter_int=secret_target_counter_int, data_bytes=p_secret_flag_bytes, current_constants_tuple=selected_constants, rounds_to_execute=rounds_to_run)
    c_target_flag_hex = c_target_flag_bytes.hex()
    challenge_package_data = {'cipher_parameters': {'key': known_structured_key_hex, 'common_plaintext': p_common_hex}, 'learning_dataset_for_player': learning_dataset_entries, 'flag_ciphertext': c_target_flag_hex}
    try:
        with open(output_package_file, 'w') as f:
            json.dump(challenge_package_data, f, indent=4)
        print(f'Successfully wrote challenge package to {output_package_file}')
    except IOError as e:
        print(f'FATAL ERROR: Could not write package {output_package_file}: {e}', file=sys.stderr)
        sys.exit(1)

    print('\nCTF Data generation complete.')

def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('--output_file', type=str, default='ctf_nc_recovery_pkg.json', help='Filename for the single JSON challenge package.')
    parser.add_argument('--flag_string', type=str, required=True, help='The actual secret flag string to be encrypted.')
    parser.add_argument('--rounds', type=int, default=1, help='Actual number of rounds to execute (1-8, default: 2 for a very weak variant).')
    parser.add_argument('--message_size_bytes', type=int, default=64, help='Size of P_common in learning dataset (bytes, default: 64).')
    parser.add_argument('--known_key_active_material_hex', type=str, required=True, help='Hex string for the non-zero part of the known key. ')
    parser.add_argument('--secret_target_nonce_hex', type=str, required=True, help='SECRET nonce (hex, 24 chars, first 4 hex chars/2 bytes must be \'0000\') to be recovered by player. Typically from set_secrets.sh.')
    parser.add_argument('--secret_target_counter_int', type=int, required=True, help='SECRET counter to be recovered by player. Typically from set_secrets.sh.')
    parser.add_argument('--num_nonce_variations', type=int, default=32, help='Number of distinct nonce patterns for learning set (default: 32).')
    parser.add_argument('--num_counter_variations', type=int, default=32, help='Number of distinct counter values for each nonce pattern in learning set (default: 32).')
    args = parser.parse_args()
    if not 1 <= args.rounds <= 8:
        print('ERROR: --rounds must be 1-8.', file=sys.stderr)
        sys.exit(1)
    try:
        bytes.fromhex(args.known_key_active_material_hex)
    except ValueError:
        print('ERROR: --known_key_active_material_hex invalid hex.', file=sys.stderr)
        sys.exit(1)
    if len(args.secret_target_nonce_hex)!= 24 or not args.secret_target_nonce_hex.startswith('0000'):
        print('ERROR: --secret_target_nonce_hex must be 24 hex chars and start with \'0000\'.', file=sys.stderr)
        sys.exit(1)
    try:
        bytes.fromhex(args.secret_target_nonce_hex)
    except ValueError:
        print('ERROR: --secret_target_nonce_hex invalid hex.', file=sys.stderr)
        sys.exit(1)
    if args.num_nonce_variations < 1 or args.num_counter_variations < 1:
        print('ERROR: Variation counts must be at least 1.', file=sys.stderr)
        sys.exit(1)
    if args.message_size_bytes < 1:
        print('ERROR: --message_size_bytes must be at least 1.', file=sys.stderr)
        sys.exit(1)
    output_package_file_path = Path(args.output_file)
    output_package_file_path.parent.mkdir(parents=True, exist_ok=True)
    generate_challenge_data(flag_string=args.flag_string, rounds_to_run=args.rounds, message_size_bytes=args.message_size_bytes, known_key_active_material_hex=args.known_key_active_material_hex, secret_target_nonce_hex=args.secret_target_nonce_hex, secret_target_counter_int=args.secret_target_counter_int, num_nonce_variations=args.num_nonce_variations, num_counter_variations=args.num_counter_variations, output_package_file=output_package_file_path)
if __name__ == '__main__':
    main()
```

file json:

```json
{
    "cipher_parameters": {
        "key": "000000005c5470020000000031f4727bf7d4923400000000e7bbb1c900000000",
        "common_plaintext": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392"
    },
    "learning_dataset_for_player": [
        {
            "sample_id": "sample_n0_c0",
            "plaintext_hex": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392",
            "ciphertext_hex": "d4922d0bae1521cffe67ab68fd132595c4942d350ff30c906325faca486555dc2ac805afddd31f16401ab7e1ebccdfc7e765f6a76746e822dd7002a2691f9392",
            "nonce_hex": "010000000000000000000000",
            "counter_int": 1
        },
        {
            "sample_id": "sample_n0_c1",
            "plaintext_hex": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392",
            "ciphertext_hex": "d4922d7bae1521cffe67ab68fd132595fcacadb20ff30c906325faca486555dc3ac806aeddd31f16401ab7e1ebccdfc79665f6a46746e822dd7002a2691f9392",
            "nonce_hex": "010000000000000000000000",
            "counter_int": 2
        },
        {
            "sample_id": "sample_n0_c2",
            "plaintext_hex": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392",
            "ciphertext_hex": "d4922d5bae1521cffe67ab68fd132595edbcadb30ff30c906325faca486555dc5ac800acddd31f16401ab7e1ebccdfc7a865f6a26746e822dd7002a2691f9392",
            "nonce_hex": "010000000000000000000000",
            "counter_int": 4
        },
        {
            "sample_id": "sample_n0_c3",
            "plaintext_hex": "9de16236ae1521cffe67ab68fd1325951b2a1b11b75bec946325faca2a8db02a013b9c18ddd31f168e6dd472ebccdfc7d92c85e96546e822dd7002a2691f9392",
            "ciphertext_hex": "d4922d9bae1521cffe67ab68fd132595f3dcadb10ff30c906325faca486555dc9ac83ca8ddd31f16401ab7e1ebccdfc76c65f6ae6746e822dd7002a2691f9392",
            "nonce_hex": "010000000000000000000000",
            "counter_int": 8
        },
        ...
    ],
    "flag_ciphertext": "692f09e677335f6152655f67304e6e40141fa702e7e5b95b46756e63298d80a9bcbbd95465795f21ef0a"
}
```

Source code c·ªßa b√†i n√≥i v·ªÅ lo·∫°i m√£ h√≥a `ChaCha20 Cipher`. H·ªç m√£ h√≥a c√πng m·ªôt plaintext nh∆∞ng v·ªõi c√°c `nonce, counter` kh√°c nhau ƒë·ªÉ l·∫•y ƒë∆∞·ª£c c√°c ciphertext kh√°c nhau.

Nh∆∞ ta ƒë√£ bi·∫øt `ChaCha20` l√† m·ªôt lo·∫°i stream cipher, n√¥m na l√† ki·ªÉu m√£ h√≥a n√£y s·∫Ω s·ª≠ d·ª•ng `key, nonce, counter` ƒë·ªÉ m√£ h√≥a ra `keystream` sau ƒë√≥ t√≠nh `ciphertext = plaintext XOR keystream`.

Th√¨ sau khi th·ª≠ in ra v√† quan s√°t m·ªôt s·ªë `keystream` c·ªßa nhi·ªÅu c·∫∑p trong file json th√¨ m√¨nh nh·∫≠n th·∫•y ƒë∆∞·ª£c 1 ƒëi·ªÉm chung ƒë√°ng ng·ªù ƒë√≥ l√† c√°c `keystream` ƒë·ªÅu c√≥ d·∫°ng:
```
0 5d734ffd
1 00000000
2 00000000
3 00000000
4 62d7208e
5 b8a8e004
6 00000000
7 62e8e5f6
8 ea07e66c
9 00000000
10 ce776393
11 00000000
12 495f7302
13 00000000
14 00000000
15 00000024
```
C√°c words (1 words = 4 bytes) trong `keystream` m√† b·∫±ng `0000` s·∫Ω lu√¥n c·ªë ƒë·ªãnh v·ªõi m·ªçi `keystream` kh√°c nhau. C√°c `keystream` kh√°c nhau ch·ªâ kh√°c ·ªü c√°c words c√≥ v·ªã tr√≠ `0, 4, 5, 7, 8, 10, 12, 15`. ƒêi·ªÅu n√†y x·∫£y ra l√† do `key` c·ªßa ta c≈©ng c√≥ d·∫°ng t∆∞∆°ng t·ª± nh∆∞ v·∫≠y, c≈©ng c√≥ d·∫°ng l√† words 4 bytes n·∫±m gi·ªØa c√°c words `0000`. C·ªông th√™m vi·ªác trong source code c√≥ ƒë·ªÅ c·∫≠p ƒë·∫øn s·ªë rounds ƒë∆∞·ª£c s·ª≠ d·ª•ng trong `Chacha` l√†:
```python
parser.add_argument('--rounds', type=int, default=1, help='Actual number of rounds to execute (1-8, default: 2 for a very weak variant).')
```

1 ƒëi·ªÅu ƒë√°ng l∆∞u √Ω n·ªØa ƒë√≥ l√† `flag_ciphertext` c·ªßa ta c√≥ 11 words. T·ª©c l√† ta ch·ªâ c·∫ßn t√¨m 11 words ƒë·∫ßu ti√™n c·ªßa `keystream` th√¥i l√† ƒë·ªß ƒë·ªÉ gi·∫£i m√£ r·ªìi.

Ta th·∫•y r·∫±ng, n·∫øu nh∆∞ `rounds=1` th√¨ `qr_operations_sequence` s·∫Ω ch·ªâ th·ª±c hi·ªán ƒë∆∞·ª£c b∆∞·ªõc ƒë·∫ßu ti√™n ƒë√≥ l√† `mix_bits(s, 0, 4, 8, 12)`. Sau ƒë√≥ add t·ª´ng tr·∫°ng th√°i v·ªõi m·ªói tr·∫°ng th√°i tr∆∞·ªõc thay ƒë·ªïi c·ªßa n√≥.

V√¨ ƒë√£ bi·∫øt `key`, ta c√≥ th·ªÉ t·∫°o l·∫°i ƒë∆∞·ª£c m·∫£ng `state` ban ƒë·∫ßu s·∫Ω lu√¥n lu√¥n c√≥ d·∫°ng l√†: `[0, 0, 0, 0, 0, 40916060, 0, 2071131185, 882038007, 0, 3383868391, 0, 0, 0, 0, 0]` v·ªõi `state[12]` ƒë∆∞·ª£c t√≠nh d·ª±a tr√™n `counter` c√≤n 3 `state` cu·ªëi ƒë∆∞·ª£c t√≠nh d·ª±a tr√™n `nonce`. T·ª´ 3 gi√° tr·ªã `state[0], state[4], state[8]` tr∆∞·ªõc khi `mix` v√† `state[0] = xor(b'CTF{', flag_ciphertext[:4])` sau khi `mix` ƒë√£ bi·∫øt, ta ho√†n to√†n c√≥ th·ªÉ reverse ƒëo·∫°n code trong h√†m `mix_bits` ƒë·ªÉ t√¨m ƒë∆∞·ª£c `state[12]` ban ƒë·∫ßu (vi·∫øt l·∫°i h√†m `rotr32, sub32`).
```python
a = xor(b'CTF{', flag_ciphertext[:4])
a = bytes_to_words(a)  # 2639231786
a = 2639231786
b = a
b = rotr32(b, 12)
c = b
d = sub32(c, 882038007)
d = rotr32(d, 16)
counter_int = d
```

Sau khi t√¨m ƒë∆∞·ª£c `counter` r·ªìi th√¨ ƒë∆∞a n√≥ v√†o l·∫°i h√†m `get_bytes` ƒë·ªÉ m√£ h√≥a `keystream`, r·ªìi l·∫•y 11 words ƒë·∫ßu ti√™n ƒë·ªÉ gi·∫£i m√£ v√† l·∫•y flag.

Code solve:
```python
import argparse
import json
import os
import struct
import sys
from pathlib import Path
from pwn import xor
CHACHA_CONSTANTS = (1634760805, 857760878, 2036477234, 1797285236)

def rotr32(v, c):
    v &= 0xffffffff
    return ((v >> c) | (v << (32 - c))) & 0xffffffff

def sub32(a, b):
    return (a - b) & 0xffffffff

def rotl32(v, c):
    """Rotate a 32-bit unsigned integer left by c bits."""  # inserted
    v &= 4294967295
    return v << c & 4294967295 | v >> 32 - c

def add32(a, b):
    """Add two 32-bit unsigned integers, wrapping modulo 2^32."""  # inserted
    return a + b & 4294967295

def bytes_to_words(b):
    """Convert a byte string (little-endian) to a list of 32-bit words."""  # inserted
    if len(b) % 4!= 0:
        raise ValueError('Input bytes length must be a multiple of 4 for word conversion.')
    return list(struct.unpack('<' + 'I' * (len(b) // 4), b))

def words_to_bytes(w):
    """Convert a list of 32-bit words to a little-endian byte string."""  # inserted
    return struct.pack('<' + 'I' * len(w), *w)

def mix_bits(state_list, a_idx, b_idx, c_idx, d_idx):
    """\n    Mixes Bits. Modifies state_list in-place.\n    """  # inserted
    a, b, c, d = (state_list[a_idx], state_list[b_idx], state_list[c_idx], state_list[d_idx])
    a = add32(a, b)
    d ^= a
    d = rotl32(d, 16)
    c = add32(c, d)
    b ^= c
    b = rotl32(b, 12)
    a = add32(a, b)
    d ^= a
    d = rotl32(d, 8)
    c = add32(c, d)
    b ^= c
    b = rotl32(b, 7)
    state_list[a_idx], state_list[b_idx], state_list[c_idx], state_list[d_idx] = (a, b, c, d)

def make_block(key_bytes, nonce_bytes, counter_int, current_constants_tuple, rounds_to_execute=8):
    """\n    Generates one 64-byte block of bits, allowing control over the\n    number of rounds executed.\n    """  # inserted
    if len(key_bytes)!= 32:
        raise ValueError('Key must be 32 bytes')
    if len(nonce_bytes)!= 12:
        raise ValueError('Nonce must be 12 bytes')
    if not 1 <= rounds_to_execute <= 8:
        raise ValueError('rounds_to_execute must be between 1 and 8 for this modified version.')
    state = [0] * 16
    state[0:4] = current_constants_tuple
    try:
        key_words = bytes_to_words(key_bytes)
        nonce_words = bytes_to_words(nonce_bytes)
    except ValueError as e:
        raise ValueError(f'Error converting key/nonce to words: {e}')
    state[4:12] = key_words
    state[12] = counter_int & 4294967295
    state[13:16] = nonce_words
    initial_state_snapshot = list(state)
    qr_operations_sequence = [
        lambda s: mix_bits(s, 0, 4, 8, 12),
        lambda s: mix_bits(s, 1, 5, 9, 13),
        lambda s: mix_bits(s, 2, 6, 10, 14),
        lambda s: mix_bits(s, 3, 7, 11, 15),
        lambda s: mix_bits(s, 0, 5, 10, 15),
        lambda s: mix_bits(s, 1, 6, 11, 12),
        lambda s: mix_bits(s, 2, 7, 8, 13),
        lambda s: mix_bits(s, 3, 4, 9, 14)
    ]
    for i in range(rounds_to_execute):
        qr_operations_sequence[i](state)
    for i in range(16):
        state[i] = add32(state[i], initial_state_snapshot[i])
    return words_to_bytes(state)
struct.zeros = (0, 0, 0, 0)

def get_bytes(key_bytes, nonce_bytes, initial_counter_int, data_bytes, current_constants_tuple, rounds_to_execute=8):
    """\n    Encrypts or decrypts data using a mysterious cipher.\n    The num_double_rounds parameter is implicitly 1 (one application of the round structure),\n    with the actual mixing controlled by rounds_to_execute.\n    """  # inserted
    output_byte_array = bytearray()
    current_counter = initial_counter_int & 4294967295
    data_len = len(data_bytes)
    block_idx = 0
    while block_idx < data_len:
        try:
            keystream_block = make_block(key_bytes, nonce_bytes, current_counter, current_constants_tuple, rounds_to_execute=rounds_to_execute)
        except Exception as e:
            raise Exception(f'Error in make_block during stream processing for counter {current_counter}: {e}')
        remaining_data_in_block = data_len - block_idx
        chunk_len = min(64, remaining_data_in_block)
        for i in range(chunk_len):
            output_byte_array.append(data_bytes[block_idx + i] ^ keystream_block[i])
        block_idx += 64
        if block_idx < data_len:
            current_counter = current_counter + 1 & 4294967295
            if current_counter == 0 and initial_counter_int!= 0 and (data_len > 64):
                print(f'Warning: counter for nonce {nonce_bytes.hex()} wrapped around to 0 during a multi-block message.')
    return bytes(output_byte_array)

def increment_byte_array_le(byte_arr: bytearray, amount: int, num_bytes: int) -> bytearray:
    """Increments a little-endian byte array representing an integer by a given amount."""  # inserted
    if len(byte_arr)!= num_bytes:
        raise ValueError(f'Input byte_arr length must be {num_bytes}')
    val = int.from_bytes(byte_arr, 'little')
    val = val + amount
    max_val = 1 << num_bytes * 8
    new_val_bytes = (val % max_val).to_bytes(num_bytes, 'little', signed=False)
    return bytearray(new_val_bytes)


key = "000000005c5470020000000031f4727bf7d4923400000000e7bbb1c900000000"
key = bytes.fromhex(key)
flag_ciphertext = "692f09e677335f6152655f67304e6e40141fa702e7e5b95b46756e63298d80a9bcbbd95465795f21ef0a"
flag_ciphertext = bytes.fromhex(flag_ciphertext)

a = xor(b'CTF{', flag_ciphertext[:4])
a = bytes_to_words(a)
a = 2639231786
b = a
b = rotr32(b, 12)
c = b
d = sub32(c, 882038007)
d = rotr32(d, 16)
counter_int = d

selected_constants = struct.zeros
known_structured_key_bytes = key

state = [0] * 16
state[0:4] = selected_constants
state[4:12] = bytes_to_words(key)

flag = get_bytes(known_structured_key_bytes, b'\x00'*12, counter_int, flag_ciphertext, selected_constants, rounds_to_execute=1)
print(flag)

# CTF{w3_aRe_g0Nn@_ge7_MY_FuncKee_monkey_!!}
```




## FILTERMAZE
Source code:
```python
# filtermaze.py
import json
import secrets
import sys
from dataclasses import asdict, dataclass, field
from typing import List

import numpy as np

# This is a placeholder path for local testing.
# On the real server, this will be a secret, longer path.
SECRET_HAMILTONIAN_PATH = [0]


@dataclass
class LWEParams:
  lwe_n: int = 50
  lwe_m: int = 100
  lwe_q: int = 1009
  A: List[int] = field(init=False)
  s: List[int] = field(init=False)
  e: List[int] = field(init=False)
  b: List[int] = field(init=False)

  def __post_init__(self):
    self.lwe_error_range = [secrets.randbelow(self.lwe_q) for _ in range(self.lwe_m)]


def load_graph(filepath):
  with open(filepath, "r") as f:
    graph_data = json.load(f)
  return {int(k): v for k, v in graph_data.items()}


def load_flag(filepath):
  with open(filepath, "r") as f:
    flag = f.readline().strip()
  return flag


def create_lwe_instance_with_error(n, m, q, error_mags):
  s = np.array([secrets.randbelow(q) for _ in range(n)], dtype=int)
  A = np.random.randint(0, q, size=(m, n), dtype=int)  # Public matrix
  e = np.array([secrets.choice([-mag, +mag]) for mag in error_mags], dtype=int)
  b = (A @ s + e) % q
  return A.tolist(), s.tolist(), e.tolist(), b.tolist()


class PathChecker:
  def __init__(
    self,
    secret_path,
    graph_data,
    lwe_error_mags,
  ):
    self.secret_path = secret_path
    self.graph = graph_data
    self.lwe_error_mags = lwe_error_mags
    self.path_len = len(self.secret_path)

  def check(self, candidate_segment):
    seg_len = len(candidate_segment)
    if seg_len > self.path_len:
      return False
    for i, node in enumerate(candidate_segment):
      if node != self.secret_path[i]:  # Node mismatch
        return False

      if i > 0:
        prev_node = candidate_segment[i - 1]
        neighbors = self.graph.get(prev_node)
        if neighbors is None or node not in neighbors:
          return False

    if seg_len == self.path_len:
      error_magnitudes = [int(abs(err_val)) for err_val in self.lwe_error_mags]
      return error_magnitudes
    else:
      return True


def main():
  flag = load_flag("flag")
  graph_data = load_graph("graph.json")
  lwe_params = LWEParams()
  if len(sys.argv) > 1:
    if sys.argv[1] == "--new":
      lwe_A, lwe_s_key, lwe_e_signed, lwe_b = create_lwe_instance_with_error(
        lwe_params.lwe_n, lwe_params.lwe_m, lwe_params.lwe_q, lwe_params.lwe_error_range
      )
      lwe_params.A = lwe_A
      lwe_params.b = lwe_b
      lwe_params.s = lwe_s_key
      lwe_params.e = lwe_e_signed
      with open("lwe_secret_params.json", "w") as s:
        json.dump(asdict(lwe_params), s, indent=2)
  else:
    with open("lwe_secret_params.json", "r") as s:
      lwe_params = json.load(s)
    lwe_A = lwe_params.get("A")
    lwe_s_key = lwe_params.get("s")
    lwe_e_signed = lwe_params.get("e")
    lwe_b = lwe_params.get("b")

  path_checker = PathChecker(
    secret_path=SECRET_HAMILTONIAN_PATH,
    graph_data=graph_data,
    lwe_error_mags=lwe_e_signed,
  )

  initial_messages = [
    "Welcome! I've hidden the key at the end of the maze. You can use this to open the chest to get the flag.",
    'Commands: {"command": "check_path", "segment": [...]}',
    '          {"command": "get_flag", "lwe_secret_s": [...] }',
  ]
  for msg in initial_messages:
    print(msg, flush=True)

  for line in sys.stdin:
    data_str = line.strip()
    if not data_str:
      continue

    response_payload = {}
    try:
      client_command = json.loads(data_str)
      command = client_command.get("command")

      if command == "check_path":
        segment = client_command.get("segment")
        if not isinstance(segment, list):
          raise TypeError("Segment must be a list.")
        path_result = path_checker.check(segment)

        if isinstance(path_result, list):
          response_payload = {
            "status": "path_complete",
            "lwe_error_magnitudes": path_result,
          }
        elif path_result is True:
          response_payload = {"status": "valid_prefix"}
        else:
          response_payload = {"status": "path_incorrect"}
      elif command == "get_flag":
        key_s_raw = client_command.get("lwe_secret_s")
        if not isinstance(key_s_raw, list):
          raise TypeError("lwe_secret_s must be a list.")

        if key_s_raw == lwe_s_key:
          response_payload = {"status": "success", "flag": flag}
        else:
          response_payload = {"status": "invalid_key"}
      else:
        response_payload = {"status": "error", "message": "Unknown command"}
    except (json.JSONDecodeError, ValueError, TypeError) as e:
      json_err = f"Invalid format or data: {e}"
      response_payload = {
        "status": "error",
        "message": json_err,
      }
    except Exception as e_cmd:
      err_mesg = f"Error processing command '{data_str}': {e_cmd}"
      response_payload = {"status": "error", "message": err_mesg}

    print(json.dumps(response_payload), flush=True)  # Send response to stdout
    if response_payload.get("flag"):
      break


if __name__ == "__main__":
  main()
```

### Part 1:
Ta ƒë∆∞·ª£c cung c·∫•p cho m·ªôt ƒë·ªë th·ªã g·ªìm 30 ƒë·ªânh, m·ª•c ƒë√≠ch l√† l√†m th·∫ø n√†o ƒë·ªÉ ta c√≥ th·ªÉ t√¨m ra ƒë∆∞·ª£c `Hamilton path` c·ªßa server. B√†i to√°n t√¨m ƒë∆∞·ªùng ƒëi Hamilton l√† b√†i to√°n `NP-Complete`, n·∫øu nh∆∞ ta mu·ªën t√¨m h·∫øt t·∫•t c·∫£ c√°c ƒë∆∞·ªùng ƒëi Hamilton c·ªßa ƒë·ªì th·ªã th√¨ ƒë·ªô ph·ª©c t·∫°p r·∫•t l·ªõn `O(N!)` ho·∫∑c `O(N^2*2^N)`. Kh√¥ng th·ªÉ t√¨m nh∆∞ v·∫≠y trong b√†i n√†y v√¨ `N = 30`. M√¨nh ƒë·ªçc ti·∫øp trong source code th√¨ ph√°t hi·ªán ra:
```python
elif path_result is True:
    response_payload = {"status": "valid_prefix"}
```
Server c√≥ th·ªÉ cho ta bi·∫øt ƒë∆∞·ªùng ƒëi Hamilton c·ªßa ta tr√πng v·ªõi prefix ƒë∆∞·ªùng ƒëi c·ªßa server. T·ª´ ƒë√≥ ta c√≥ th·ªÉ d·ªÖ d√†ng bruteforce t·ª´ng ƒë·ªânh c·ªßa ƒë∆∞·ªùng ƒëi.

### Part 2:
Sau khi t√¨m ƒë∆∞·ª£c ƒë∆∞·ªùng ƒëi ƒë√∫ng r·ªìi, server tr·∫£ cho ta m·ªôt list `lwe_error_magnitudes`. ƒê√¢y ch√≠nh l√† **gi√° tr·ªã tuy·ªát ƒë·ªëi** c·ªßa vector `e` ƒë∆∞·ª£c sinh ra trong h√†m `create_lwe_instance_with_error`.

√ù nghƒ©a c·ªßa h√†m `create_lwe_instance_with_error` l√† t√≠nh:

$$
A * s + e = b \pmod q
$$

V·ªõi ma tr·∫≠n $A$, vector $b$, vector $\mid e \mid$, s·ªë nguy√™n $q$ ƒë√£ bi·∫øt. Vi·ªác c·ªßa ta l√† t√¨m vector $s$ ƒë·ªÉ l·∫•y flag. Ta c√≥ ph∆∞∆°ng tr√¨nh d∆∞·ªõi d·∫°ng t·ª´ng h√†ng c·ªßa ma tr·∫≠n:

$$
\begin{cases}
a_1s+e_1=b_{1}\pmod q\\
a_2s+e_2=b_{2}\pmod q\\
\vdots\\
a_ms+e_m=b_{m}\pmod q
\end{cases}

<=>

\begin{cases}
\frac{a_1}{|e_1|}s + \frac{e_1}{|e_1|} = \frac{b_1}{|e_1|} \pmod q \\
\frac{a_2}{|e_2|}s + \frac{e_2}{|e_2|} = \frac{b_2}{|e_2|} \pmod q \\
\vdots \\
\frac{a_m}{|e_m|}s + \frac{e_m}{|e_m|} = \frac{b_m}{|e_m|} \pmod q \\
\end{cases}

<=>

\begin{cases}
\frac{a_1}{|e_1|}s + k_1q = \frac{b_1}{|e_1|} - \frac{e_1}{|e_1|} \\
\frac{a_2}{|e_2|}s + k_2q = \frac{b_2}{|e_2|} - \frac{e_2}{|e_2|} \\
\vdots \\
\frac{a_m}{|e_m|}s + k_mq = \frac{b_m}{|e_m|} - \frac{e_m}{|e_m|} \\
\end{cases}
$$

G·ªçi `A', b'` l√† ma tr·∫≠n v√† vector sau khi chia cho `|e|`.
M√¥ ph·ªèng b·∫±ng ph√©p nh√¢n ma tr·∫≠n:

$$
\left[\begin{array}{cccccccc}
a'_{11} & a'_{12} & \cdots & a'_{1n} & q & 0 & \cdots & 0\\
a'_{21} & \ddots &  & \vdots & 0 & q &  & \vdots\\
\vdots &  & \ddots & \vdots & \vdots &  & \ddots & \vdots\\
a'_{m1} & \cdots & \cdots & a'_{mn} & 0 & \cdots & \cdots & q
\end{array}\right]\left[\begin{array}{c}
s_{1}\\
\vdots\\
s_{n}\\
k_{1}\\
\vdots\\
k_{m}
\end{array}\right]=b'-e'
$$

T∆∞∆°ng ƒë∆∞∆°ng:

$$
s_{1}\left[\begin{array}{c}
a'_{11}\\
a'_{21}\\
\vdots\\
a'_{m1}
\end{array}\right]+\cdots+s_{n}\left[\begin{array}{c}
a'_{1n}\\
a'_{2}\\
\vdots\\
a'_{mn}
\end{array}\right]+k_{1}\left[\begin{array}{c}
q\\
0\\
\vdots\\
0
\end{array}\right]+k_{2}\left[\begin{array}{c}
0\\
q\\
\vdots\\
0
\end{array}\right]+\cdots+k_{m}\left[\begin{array}{c}
0\\
0\\
\vdots\\
q
\end{array}\right]=b'-e'
$$

Ta bi·∫øt r·∫±ng, vector $\frac{e}{\mid e \mid}$ s·∫Ω l√† m·ªôt vector ch·ªâ ch·ª©a c√°c h·ªá s·ªë l√† $0, 1, -1$ (r·∫•t nh·ªè). Nh·ªù ƒëi·ªÅu ƒë√≥, b√†i to√°n tr·ªü th√†nh t√¨m vector g·∫ßn vector $b'$ nh·∫•t (CVP). S·ª≠ d·ª•ng LLL v√† [Thu·∫≠t to√°n BaiBai](https://eprint.iacr.org/2023/032.pdf) ƒë·ªÉ gi·∫£i quy·∫øt. Sau khi t√¨m ƒë∆∞·ª£c vector $t$ g·∫ßn vector $b$ nh·∫•t r·ªìi, ta ƒë√£ c√≥ $As \approx t$, th√¨ d√πng h√†m `solve_right()` c√≥ s·∫µn trong `sage` ƒë·ªÉ t√¨m l·∫°i vector `s`.

Code:
```python
from pwn import *
import subprocess
import re
import tempfile
import os
import json
from sage.all import *
from sage.modules.free_module_integer import IntegerLattice
import json

p = remote("filtermaze.2025.ctfcompetition.com", 1337, level='debug')

pow_prompt = p.recvuntil(b"Solution?").decode()
challenge_id = re.search(r"solve (s\.[^\s]+)", pow_prompt).group(1)
with tempfile.NamedTemporaryFile("w+", delete=False) as tmpf:
    tmpf.write(subprocess.check_output(["curl", "-sSL", "https://goo.gle/kctf-pow"]).decode())
    tmpf.flush()
    pow_script_path = tmpf.name
solution = subprocess.check_output(["python3", pow_script_path, "solve", challenge_id]).strip()
p.sendline(solution)
p.recvuntil(b'[...] }\n')


path, e = [], []
for _ in range(30):
    for node in range(30):
        if node in path:
            continue
        path.append(node)
        payload = {"command": "check_path", "segment": path}
        p.sendline(json.dumps(payload))
        response = p.recvline().decode().strip()

        if 'path_complete' in response:
            e = json.loads(response)['lwe_error_magnitudes']
            break

        if 'valid_prefix' in response:
            break
        else:
            path.pop()

n, m, q = 50, 100, 1009
def Babai_closest_vector(M, G, target):
    small = target
    for _ in range(1):
        for i in reversed(range(M.nrows())):
            c = ((small * G[i]) / (G[i] * G[i])).round()
            small -= M[i] * c
    return target - small


with open("/home/team/CodePy/GoogleCTF2025/crypto-filtermaze/lwe_pub_params.json", "r") as f:
    data = json.load(f)
    A = Matrix(GF(q), m, n, data["A"])
    b = list(vector(GF(q), data["b"]))

e = vector(GF(q), e)
M = Matrix(ZZ, m + n, m)
for i in range(m):
    M[i, i] = q
    b[i] = b[i] / e[i]
for x in range(m):
    for y in range(n):
        A[x, y] = A[x, y] / e[x]
        M[m + y, x] = int(A[x, y])

lattice = IntegerLattice(M, lll_reduce=True)
gram = lattice.reduced_basis.gram_schmidt()[0]
target = vector(ZZ, b)
res = Babai_closest_vector(lattice.reduced_basis, gram, target)
s = A.solve_right(vector(GF(q), res))

p.sendline(json.dumps({"command": "get_flag", "lwe_secret_s": [int(x) for x in s]}))
flag = p.recvline().decode().strip()
print(flag)

os.remove(pow_script_path)

# CTF{d4_sup3r_sh0rt_3rr0r_v3ct0r_1s_th3_k3y}
```


## MERKURATED
Server script:
```python
import sys
import signal
import hashlib
import bcrypt
import os
from ecdsa.ecdsa import Signature
from ecdsa.curves import NIST256p

def tle_handler(*args):
    print('‚è∞')
    sys.exit(0)

def hash(message, salt):
    h = bcrypt.hashpw(message, salt)
    _salt, h = h[:29], h[29:]
    assert salt == _salt
    return h

def recover_public_key(message, signature):
    hash = int.from_bytes(hashlib.sha256(message).digest(), 'big')
    r, s = [int.from_bytes(signature[i:i+32], 'big') for i in range(0, 64, 32)]
    v = signature[64]

    public_keys = Signature(r, s).recover_public_keys(hash, NIST256p.generator)
    x = public_keys[v].point.x()
    return int.to_bytes(int(x), 32, 'big')

SALT_FOR_NODE    = bcrypt.gensalt(4)
SALT_FOR_VALUE   = bcrypt.gensalt(4)
EMPTY_NODE_HASH  = hash(b'', SALT_FOR_NODE)
EMPTY_VALUE_HASH = hash(b'', SALT_FOR_VALUE)


class RadixTree:
    def __init__(self):
        self.value = None
        self.left_subtree = None
        self.right_subtree = None
        self.cached_hash = None

    def _set(self, hash_key, value, depth=0):
        self.cached_hash = None

        if depth == 256:
            self.value = value
            return

        if hash_key & 1 == 0:
            if self.left_subtree is None:
                self.left_subtree = RadixTree()
            self.left_subtree._set(hash_key>>1, value, depth+1)
        else:
            if self.right_subtree is None:
                self.right_subtree = RadixTree()
            self.right_subtree._set(hash_key>>1, value, depth+1)

    def set(self, key, value):
        hash_key = hashlib.sha256(key).digest()
        hash_key = int.from_bytes(hash_key, 'big')
        self._set(hash_key, value)

    def _get(self, hash_key, depth=0):
        if depth == 256 and self.value is not None:
            return self.value

        if hash_key & 1 == 0 and self.left_subtree is not None:
            return self.left_subtree._get(hash_key>>1, depth+1)
        elif hash_key & 1 == 1 and self.right_subtree is not None:
            return self.right_subtree._get(hash_key>>1, depth+1)
        return 0

    def get(self, key):
        hash_key = hashlib.sha256(key).digest()
        hash_key = int.from_bytes(hash_key, 'big')
        return self._get(hash_key)

    # Show that "tree[key] = value"
    # Proof format: [value (8 bytes)][hash (31 bytes)][hash (31 bytes)]...[hash (31 bytes)]
    def verify(self, key, proof):
        hash_key = hashlib.sha256(key).digest()
        hash_key = int.from_bytes(hash_key, 'big')

        # Leaf node hash
        current_hash = hash(b':::'.join([
            EMPTY_NODE_HASH,
            EMPTY_NODE_HASH,
            hash(proof[0:8], SALT_FOR_VALUE)
        ]), SALT_FOR_NODE)

        for bit, i in zip(range(256-1, -1, -1), range(8, len(proof), 31)):
            proof_block = proof[i:i+31]
            if hash_key & (1 << bit) == 0:
                message = b':::'.join([current_hash, proof_block, EMPTY_VALUE_HASH])
                current_hash = hash(message, SALT_FOR_NODE)
            else:
                message = b':::'.join([proof_block, current_hash, EMPTY_VALUE_HASH])
                current_hash = hash(message, SALT_FOR_NODE)

        if current_hash != self.hash(): raise Exception('invalid proof')
        return int.from_bytes(proof[0:8], 'big')

    def hash(self):
        if self.cached_hash is not None:
            return self.cached_hash


        hash_material = []

        if self.left_subtree is not None:  hash_material.append(self.left_subtree.hash())
        else:                              hash_material.append(EMPTY_NODE_HASH)

        if self.right_subtree is not None: hash_material.append(self.right_subtree.hash())
        else:                              hash_material.append(EMPTY_NODE_HASH)

        if self.value is not None:         hash_material.append(hash(int.to_bytes(self.value, 8, 'big'), SALT_FOR_VALUE))
        else:                              hash_material.append(EMPTY_VALUE_HASH)

        message = b':::'.join(hash_material)
        self.cached_hash = hash(message, SALT_FOR_NODE)

        return self.cached_hash


def main():
    # The clock is ticking!
    signal.signal(signal.SIGALRM, tle_handler)
    signal.alarm(60)

    tree = RadixTree()
    with open('./flag.txt', 'r') as f:
      flag = f.read()

    print(f'üßÇ {SALT_FOR_NODE.decode()}')
    print(f'üßÇ {SALT_FOR_VALUE.decode()}')

    player_local_amount = 10**9

    while True:
        cmd, *args = input('ü§ñ ').strip().split(' ')
        if cmd == 'deposit':
            amount, public_key = int(args[0]), bytes.fromhex(args[1])
            if amount <= 0: raise Exception('invalid amount')
            if amount > player_local_amount: raise Exception('invalid amount')

            player_remote_amount = tree.get(public_key)

            player_local_amount -= amount
            tree.set(public_key, player_remote_amount + amount)

        elif cmd == 'withdraw':
            amount, signature, proof = int(args[0]), bytes.fromhex(args[1]), bytes.fromhex(args[2])
            if amount <= 0: raise Exception('invalid amount')
            public_key = recover_public_key(proof, signature)

            player_remote_amount = tree.verify(public_key, proof)
            if amount > player_remote_amount: raise Exception('invalid amount')

            player_local_amount += amount
            tree.set(public_key, player_remote_amount - amount)

        elif cmd == 'flag':
            if player_local_amount < 10**18: raise Exception('please earn more')
            print(f'üèÅ {flag}')
            sys.exit(0)


if __name__ == '__main__':
    main()
```
### Ph√¢n t√≠ch:
Server trong b√†i n√†y x√¢y d·ª±ng m·ªôt `Merkle Tree`, v√† c√≥ c√°c thao t√°c ƒë·ªÉ ta t∆∞∆°ng t√°c v·ªõi c√¢y:
1. `deposit(amount, public_key)`: tƒÉng gi√° tr·ªã c·ªßa `tree[public_key]` l√™n m·ªôt l∆∞·ª£ng `amount` $\in$ `(0, M]`.
2. `withdraw(amount, signature, proof)`: gi·∫£m `tree[public_key]` m·ªôt l∆∞·ª£ng `amount` $\in$ `(0, M]` v·ªõi `public_key` ƒë∆∞·ª£c t√≠nh l·∫°i t·ª´ `signature` v√† `proof`.
3. `flag`: l·∫•y ƒë∆∞·ª£c `flag` khi ta l√†m cho gi√° tr·ªã `M >= 10^18`.

`M` ·ªü ƒë√¢y l√† `player_local_amount`.

### Solution
Trong `Merkle tree`, m·ªói node s·ª≠ d·ª•ng c√¥ng th·ª©c hash chung nh∆∞ sau:

$$
bcrypt_N(left \ subtree \ hash \ || \ ::: \ || \ right \ subtree \ hash \ || \ ::: \ || \ bcrypt_V(value))
$$

$bcrypt_N, bcrypt_V$ l√† hash c·ªßa `bcrypt` v·ªõi c√°c `salt` l·∫ßn l∆∞·ª£t l√† `SALT_FOR_NODE` v√† `SALT_FOR_VALUE`.

Ta th·∫•y r·∫±ng, h√†m `hash` trong b√†i n√†y ch·ªâ l·∫•y 31 bytes cu·ªëi sau khi `bcrypt`. T·ª©c l√† c√°c c·ªßa chu·ªói sau khi `hash` s·∫Ω th·ªèa m√£n re `[./0-9A-Za-z]{31}`.

M·ªôt t√≠nh ch·∫•t ƒë·∫∑c bi·ªát n·ªØa c·ªßa `bcrypt` ƒë√≥ l√† `bcrypt` ch·ªâ m√£ h√≥a **72 bytes** ƒë·∫ßu ti√™n c·ªßa `message` (https://man.openbsd.org/bcrypt). ƒêi·ªÅu ƒë√≥ t∆∞∆°ng ƒë∆∞∆°ng v·ªõi:

```
123456789012345678901234567890123456789012345678901234567890123456789012
`bcrypt` would only take the up to the 72th byte for the digest        ‚Üì
LEFT_SUBTREE_HASH______________:::RIGHT_SUBTREE_HASH_____________:::VALUE_HASH_____________________
```

Gi√° tr·ªã `hash` c·ªßa m·ªói node ch·ªâ b·ªã ·∫£nh h∆∞·ªüng b·ªüi **4 bytes** ƒë·∫ßu ti√™n c·ªßa `value`.

ƒê·∫øn ƒë√¢y, ta c√≥ th·ªÉ t√¨m 2 gi√° tr·ªã:
1. `VALID_VALUE` s·∫Ω l√† gi√° tr·ªã n·∫±m trong kho·∫£ng `[0, 10^9]`.
2. `INVALID_VALUE` l√† gi√° tr·ªã n·∫±m trong kho·∫£ng `[10^18, 2^64]`.

Sao cho 2 gi√° tr·ªã ƒë√≥ sau khi `hash` th√¨ s·∫Ω c√≥ chung **4 bytes** ƒë·∫ßu ti√™n. V√¨ m·ªói byte sau khi `hash` ch·ªâ c√≥ 64 gi√° tr·ªã, n√™n s·ªë tr·∫°ng th√°i k·∫øt qu·∫£ c·ªßa ta s·∫Ω l√† $64^4$. S·ª≠ d·ª•ng ngh·ªãch l√Ω `Birthday paradox`, ta ch·ªâ c·∫ßn l·∫•y $\sqrt{64^4} = 64^2 = 2^{12}$ l·∫ßn random ƒë·ªÉ t√¨m ƒë∆∞·ª£c `collision`.

V√¨ ban ƒë·∫ßu ta ch·ªâ d√πng `deposit` 1 l·∫ßn ƒë·ªÉ `set(VALID_VALUE)`, n√™n `Merkle tree` s·∫Ω ch·ªâ c√≥ 1 ƒë∆∞·ªùng ƒëi duy nh·∫•t. T·ª´ ƒë√≥ suy ra, `proof` c·ªßa ta s·∫Ω ch·ªâ g·ªìm c√°c `EMPTY_NODE_HASH`.

T√≥m l·∫°i, c√°ch gi·∫£i quy·∫øt b√†i n√†y nh∆∞ sau:
- T·ª± t·∫°o m·ªôt b·ªô kh√≥a ECDSA ƒë·ªÉ k√Ω.
- T√¨m ƒë∆∞·ª£c 2 gi√° tr·ªã `VALID_VALUE` v√† `INVALID_VALUE` c√≥ t√≠nh ch·∫•t nh∆∞ tr√™n v√† th·ªèa m√£n ƒëi·ªÅu ki·ªán :

$10^9 - VALID \ VALUE + INVALID \ VALUE \ge 10^{18}$.
- G·ªçi h√†m `diposit(VALID_VALUE, public_key)` ƒë·ªÉ t·∫°o 1 node duy nh·∫•t tr√™n c√¢y.
- T·∫°o `proof = INVALID_VALUE + EMPTY_NODE_HASH + EMPTY_NODE_HASH + ...`.
- D√πng kh√≥a ECDSA ƒë·ªÉ k√Ω `proof`.
- G·ªçi `withdraw(INVALID_VALUE, signature, proof)` ƒë·∫øn server.

Code solve:
```python
import bcrypt
import hashlib
from ecdsa import SigningKey
from ecdsa.ecdsa import Signature
from ecdsa.curves import NIST256p
from pwn import *
from tqdm import trange
import subprocess
import re
import tempfile
import os
import json
import random

# sk = SigningKey.generate(curve=NIST256p)
# vk = sk.get_verifying_key()
# pk = vk.pubkey.point.x()

sk = '575156a1806cef06d1224c89dbafebfc1bb828fd35ca82c18b23d369875c3aa7'
sk = SigningKey.from_string(bytes.fromhex(sk), curve=NIST256p)
pk = 28300330634304417691698698855204040081570122261197191457707776099491314287830

def sign(message):
    message_hash = hashlib.sha256(message).digest()
    signature = sk.sign_digest(
        message_hash,
        sigencode=lambda r, s, order: (int(r).to_bytes(32, 'big') + int(s).to_bytes(32, 'big'))
    )
    return signature + bytes([0])





io = remote("merkurated.2025.ctfcompetition.com", 1337, level='debug')

pow_prompt = io.recvuntil(b"Solution?").decode()
challenge_id = re.search(r"solve (s\.[^\s]+)", pow_prompt).group(1)
with tempfile.NamedTemporaryFile("w+", delete=False) as tmpf:
    tmpf.write(subprocess.check_output(["curl", "-sSL", "https://goo.gle/kctf-pow"]).decode())
    tmpf.flush()
    pow_script_path = tmpf.name
solution = subprocess.check_output(["python3", pow_script_path, "solve", challenge_id]).strip()
io.sendline(solution)
io.recvline()


SALT_FOR_NODE = io.recvline().split(b' ')[-1].strip()
SALT_FOR_VALUE = io.recvline().split(b' ')[-1].strip()

def hash(message, salt):
    h = bcrypt.hashpw(message, salt)
    _salt, h = h[:29], h[29:]
    assert salt == _salt
    return h

EMPTY_NODE_HASH  = hash(b'', SALT_FOR_NODE)
EMPTY_VALUE_HASH = hash(b'', SALT_FOR_VALUE)



dic = {}
for _ in range(2**20):
    INVALID_VALUE = random.randrange(10**18, 2**64)
    VALID_VALUE = random.randrange(0, 10**9)

    if hash(int.to_bytes(INVALID_VALUE, 8, 'big'), SALT_FOR_VALUE)[:4] in dic.values():
        VALID_VALUE = list(dic.keys())[list(dic.values()).index(hash(int.to_bytes(INVALID_VALUE, 8, 'big'), SALT_FOR_VALUE)[:4])]
        print(f'Found collision: {INVALID_VALUE} -> {VALID_VALUE}')
        break

    dic[VALID_VALUE] = hash(int.to_bytes(VALID_VALUE, 8, 'big'), SALT_FOR_VALUE)[:4]


# diposit
amount = VALID_VALUE
public_key = bytes.fromhex(hex(pk)[2:])

io.sendlineafter(f'ü§ñ '.encode(), f'deposit {amount} {public_key.hex()}'.encode())


# withdraw
amount = INVALID_VALUE
proof = amount.to_bytes(8, 'big')
for _ in range(256):
    proof += EMPTY_NODE_HASH
signature = sign(proof)

io.sendlineafter(f'ü§ñ '.encode(), f'withdraw {amount} {signature.hex()} {proof.hex()}'.encode())


# flag
io.sendlineafter(f'ü§ñ '.encode(), f'flag'.encode())
io.recvuntil(f'üèÅ ')
flag = io.recvline().strip().decode()
print(f'Flag: {flag}')

#  CTF{bcryp7_h4sh_c0l11s10n_1s_tr1via1_by_d351gn}
```

## Continue ...