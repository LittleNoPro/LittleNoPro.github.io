---
title: 'ImaginaryCTF 2025'
date: 2025-09-09 00:00:00 +0700
categories: [CTF Write-up]
tags: [ECC, RSA]
published: true
description: "Write-up for ImaginaryCTF 2025"
---

Vừa qua mình có tham gia giải Imaginary CTF 2025 cùng team `laviem`, team mình kết thúc giải với vị trí thứ `22`. Đây là các bài crypto mình đã giải được.

# leaky-rsa
Source code:
```python
#!/usr/local/bin/python3
import json
from Crypto.Util.number import getPrime
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from secrets import randbelow, token_bytes
from hashlib import sha256

with open('flag.txt') as f:
    flag = f.read()

p = getPrime(512)
q = getPrime(512)
n = p * q
e = 65537
d = pow(e, -1, (p-1)*(q-1))

key_m = randbelow(n)
key_c = pow(key_m, e, n)

key = sha256(str(key_m).encode()).digest()[:16]
iv = token_bytes(16)
ct = AES.new(key, AES.MODE_CBC, IV=iv).encrypt(pad(flag.encode(), 16))

print(json.dumps({'n': n, 'c': key_c, 'iv': iv.hex(), 'ct': ct.hex()}))

def get_bit(n, k):
    return (n >> k) % 2

for _ in range(1024):
    idx = randbelow(4)
    print(json.dumps({'idx': idx}))
    try:
        response = json.loads(input())
        c = response['c'] % n
        assert c != key_c
        m = pow(c, d, n)
        b = get_bit(m, idx)
    except (json.JSONDecodeError, TypeError, KeyError, ValueError, AssertionError):
        b = 2
    print(json.dumps({'b': b}))
print(key_m)
```
Phân tích source một chút: ta thấy rằng, server sinh ra giá trị `key_m` ngẫu nhiên (dùng làm `key` để mã hóa `flag` bằng AES-CBC). Và server đã giấu nó đi bằng cách sử dụng RSA. Mục đích của ta là phải recover lại được `key_m`, ngoài ra server cho ta được phép thực hiện đúng 1024 thao tác, mỗi thao tác ta sẽ gửi giá trị `c`, server sẽ giải `m = pow(c, d, n)` và trả về bit nằm ở vị trí `idx` cho ta.

Nhưng khi đọc kĩ code bài này thì ta phát hiện một bug rất nghiêm trọng đó là: server đã trả về `key_m` ở dòng cuối cùng :)). Vậy việc đơn giản là gửi đại một số `c` nào đó để pass qua 1024 bước. Sau đó chỉ việc lấy `key_m`, decrypt AES và lấy `flag`.

Tất nhiên bài này không thể đơn giản như vậy được :))), vì vậy sau đó author đã  up phiên bản revenge cho bài này.

Code solve:
```python
from pwn import *
from Crypto.Util.number import *
from sage.all import *
from hashlib import sha256
from Crypto.Cipher import AES
import json

io = process(['python3', 'chall.py'], level='debug')
# io = remote('leaky-rsa.chal.imaginaryctf.org', 1337, level='debug')

data = io.recvline().strip().decode()
data = json.loads(data)
n = data['n']
c = data['c']
iv = bytes.fromhex(data['iv'])
ct = bytes.fromhex(data['ct'])

for _ in range(1024):
    io.recvline()
    io.sendline(json.dumps({'c': 0}))
    io.recvline()
key_m = int(io.recvline().strip().decode())

key = sha256(str(key_m).encode()).digest()[:16]
flag = AES.new(key, AES.MODE_CBC, IV=iv).decrypt(ct)
print(flag)

# ictf{p13cin9_7h3_b1t5_t0g37her_3f0068c1b9be2547ada52a8020420fb0}
```

# leaky-rsa-revenge
Source code:
```python
#!/usr/local/bin/python3
import json
from Crypto.Util.number import getPrime
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from secrets import randbelow, token_bytes
from hashlib import sha256

with open('flag.txt') as f:
    flag = f.read()

p = getPrime(512)
q = getPrime(512)
n = p * q
e = 65537
d = pow(e, -1, (p-1)*(q-1))

key_m = randbelow(n)
key_c = pow(key_m, e, n)

key = sha256(str(key_m).encode()).digest()[:16]
iv = token_bytes(16)
ct = AES.new(key, AES.MODE_CBC, IV=iv).encrypt(pad(flag.encode(), 16))

print(json.dumps({'n': n, 'c': key_c, 'iv': iv.hex(), 'ct': ct.hex()}))

def get_bit(n, k):
    return (n >> k) % 2

for _ in range(1024):
    idx = randbelow(4)
    print(json.dumps({'idx': idx}))
    try:
        response = json.loads(input())
        c = response['c'] % n
        assert c != key_c
        m = pow(c, d, n)
        b = get_bit(m, idx)
    except (json.JSONDecodeError, TypeError, KeyError, ValueError, AssertionError):
        b = 2
    print(json.dumps({'b': b}))
```
Code vẫn y chang bài trên, chỉ khác ở chỗ server sẽ không cho ta `key_m` đơn giản như vậy nữa. Vậy, ta phải nghĩ cách làm sao để có thể recover được `key_m` khi sử dụng bit oracle mà server cung cấp.

Bài này là một phiên bản cải tiến của [LSB Oracle Attack](https://cocalc.com/github/ashutosh1206/crypton/blob/master/RSA-encryption/Attack-LSBit-Oracle/README.md). Với phiên bản cổ điển, oracle chỉ trả về cho ta bit vị trí `0` (tức là lsb). Nếu ta gửi `c' = c * 2^e (mod N)`, oracle sẽ trả về lsb của `2m mod N`, khi đó:
- Nếu `2m < N` thì `2m mod N = 2m` (chắn) => oracle trả về `0`.
- Nếu `2m >= N` thì `2m mod N = 2m - N` (mà `2m` chẵn và `N` lẻ) => oracle trả về `1`.

Do đó, phép nhân thêm `2^e` vào `c` sẽ cho ta biết được `m` thuộc nửa trên `[N/2, N)` hay nửa dưới `[0, N/2)`. Nếu lặp lại phép nhân `2^e` này, ta sẽ dần dần thu hẹp lại được khoảng giá trị của `m`. Với độ phức tạp là số bit của `m`.

Đó là với trường hợp oracle chỉ trả về bit vị trí `0`. Còn trong bài này, oracle trả về một vị trí ngẫu nhiên trong khoảng `[0, 3]`, phải làm thế nào ?

Ta có:

$$
m' = m \cdot 2^{i+idx} - q \cdot N
$$

Trong đó $q = \lfloor \tfrac{m \cdot 2^{i+idx}}{N} \rfloor$. Do $i \ge 1$ và $idx \ge 0$ nên $m \cdot 2^{i+idx}$ luôn có các bit $0$ nằm ở cuối (ít nhất là $i+idx$ bit $0$). Vì vậy, các bit thấp của $m'$ sẽ hoàn toàn bị quyết định bởi $-q.N$. Cụ thể:

$$
m' \equiv -q \cdot N \pmod {2^{i+idx}}
$$

**Giả sử** ta chọn $N \equiv -1 \pmod {16}$:

$$
\Rightarrow m' \equiv -q \cdot N \equiv -q \cdot (-1) \equiv q \pmod {16}
$$

Khi đó, oracle trả về bit thứ $idx$ của $m'$ cũng chính là bit thứ $idx$ của $q$. Cụ thể hơn, oracle return:

$$
b = (q \ >> \ idx) \pmod 2 \\
\Rightarrow b = \lfloor \tfrac{q}{2^{idx}} \rfloor \pmod 2 \\
\Rightarrow b = \lfloor \tfrac{m \cdot 2^i}{N} \rfloor \pmod 2
$$

Như vậy, với mọi $idx \in [0, 3]$ thì bit mà oracle trả về cho sẽ luôn là **LSB** của $\lfloor \tfrac{m \cdot 2^i}{N} \rfloor$.


Code solve:
```python
from pwn import *
from Crypto.Util.number import *
from sage.all import *
from hashlib import sha256
from Crypto.Cipher import AES
import json

while True:
    io = process(['python3', 'chall.py'], level='debug')
    # io = remote('leaky-rsa-revenge.chal.imaginaryctf.org', 1337, level='debug')

    data = io.recvline().strip().decode()
    data = json.loads(data)
    N = data['n']
    c = data['c']
    e = 65537
    iv = bytes.fromhex(data['iv'])
    ct = bytes.fromhex(data['ct'])

    if N % 16 != 15:
        io.close()
        continue

    upper_limit = N
    lower_limit = 0
    i = 1
    while i <= 1024:
        idx = json.loads(io.recvline().strip().decode())['idx']

        chosen_ct = long_to_bytes(c * pow(2**(i+idx), e, N) % N)

        io.sendline(json.dumps({'c': bytes_to_long(chosen_ct)}).encode())
        output = json.loads(io.recvline().strip().decode())['b']

        if output == 0:
            upper_limit = (lower_limit + upper_limit) // 2
        elif output == 1:
            lower_limit = (lower_limit + upper_limit) // 2
        i += 1

    for offset in range(-10000, 10000):
        m = lower_limit + offset
        key = sha256(str(m).encode()).digest()[:16]
        cipher = AES.new(key, AES.MODE_CBC, iv)
        flag = cipher.decrypt(ct)
        if b'ictf' in flag:
            print(flag)
            exit()

# ictf{p13cin9_7h3_b1t5_t0g37her_7d092f5d43ebbf6fa60fba8c9e9ac4466daba9a71d04def7e5bf09bcce5649c8}
```