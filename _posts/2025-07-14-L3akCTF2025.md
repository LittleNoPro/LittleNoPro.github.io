---
title: 'L3akCTF 2025'
date: 2025-07-14 00:00:00 +0700
categories: [CTF Write-up]
tags: [Lattice, ECC]
published: true
description: "Write-up for L3akCTF 2025"
---

Vừa qua mình có tham gia giải L3akCTF 2025, đây là các bài mình đã làm được.

## Basic LLL
Source code:
```python
def generate():
    p = random_prime(2^1024, lbound=2^1023)
    x=randint(1,2^16)
    y=randint(1,2^256)
    a=randint(2^1023,2^1024)
    q=random_prime(2^1024)
    n=p*q
    return x,a,y,n,p

x,a,y,n,p = generate()
k = x * y + a * p
e=65537
print(f"x = {x}")
print(f"a = {a}")
print(f"n = {n}")
print(f"k = {k}")

m = b'L3AK{<Redacted>}'
flag = int.from_bytes(m, byteorder='big')
c= pow(flag, e, n)
print(f"c = {c}")

'''
x = 54203
a = 139534605978199350449870348663594126359773246906906418074945064315708552206952695156472923968554408862426942537522569163756593332601739006413404986641247624386522169136633429464195370373009454673819688653512479919153332504769835621608305089536245284458011218876474599059184828911301976396971466368457267831713
n = 12909957208634846878337953184362917609451224905637563117148705894888627434882610771803126452504238664471840340722310690445704139825753660053450331966698205860077330083433391290469454571152366284661640391190008258576947840075212180965738595761925516686689797153224716140447515370184846067654512660266993573880775530634588475842083212670090415716860925772115834314563453955681012820960922892736520042799257599331942717963921797157341454739255402633419216921702659541513141028779948257696746810146033667942181244847983610429227387863821351416689099862418820999250005071861968501333899759899513283613946626413863922604073
k = 24474689179117620559916890529357882261493825442019850679598519081287156822984032786458479363048845076078220151760752906879055457682971398809768604333650029141164831566127754715775782823279839766009120238777348170982471623193652714921064243946655726118484337862412275391615166714375745390409664610412156281691721978732319253694004232933156865189917761521085635692596755802274763409871937618659197646864593743015558828475450200247766980008744319676783526158213931581034209356092026748307730083927225249093712227456855972520574747646873074625455900058136458828591335711677741591552501530047335481073272381631524755666119
c = 11185314040721202177044508537272244264288033276739579716599246665772965854249656943282002695659011960313245796587834222078633141747802754149848079632693280265262199729548775879612614113828267471629389698999657686858047585254549801752634049341009476489652456620836030696102393122618822021082792763848220677651608135328630551380537642144416978955966827336280510774254681264136102268730343853559751471313539810499170669215479225898738527316798768622089152851154959800113070358637984124299357803777453137311143202502153552192970732744885328421213081964363890280109214401691255867427694709196120824176729643585687319321473
'''
```
Bài này yêu cầu ta phải giải phương trình 2 ẩn:

$$
x * y + a * p = k
$$

biết `x, a, k`. Đây là một bải giải phương trình cơ bản cổ điển sử dụng thuật toán LLL. Mọi người tham khảo các build ma trận ở [đây](https://magicfrank00.github.io/writeups/posts/lll-to-solve-linear-equations/#).


Code:
```python
from sage.all import *
from Crypto.Util.number import *

x = 54203
a = 139534605978199350449870348663594126359773246906906418074945064315708552206952695156472923968554408862426942537522569163756593332601739006413404986641247624386522169136633429464195370373009454673819688653512479919153332504769835621608305089536245284458011218876474599059184828911301976396971466368457267831713
n = 12909957208634846878337953184362917609451224905637563117148705894888627434882610771803126452504238664471840340722310690445704139825753660053450331966698205860077330083433391290469454571152366284661640391190008258576947840075212180965738595761925516686689797153224716140447515370184846067654512660266993573880775530634588475842083212670090415716860925772115834314563453955681012820960922892736520042799257599331942717963921797157341454739255402633419216921702659541513141028779948257696746810146033667942181244847983610429227387863821351416689099862418820999250005071861968501333899759899513283613946626413863922604073
k = 24474689179117620559916890529357882261493825442019850679598519081287156822984032786458479363048845076078220151760752906879055457682971398809768604333650029141164831566127754715775782823279839766009120238777348170982471623193652714921064243946655726118484337862412275391615166714375745390409664610412156281691721978732319253694004232933156865189917761521085635692596755802274763409871937618659197646864593743015558828475450200247766980008744319676783526158213931581034209356092026748307730083927225249093712227456855972520574747646873074625455900058136458828591335711677741591552501530047335481073272381631524755666119
c = 11185314040721202177044508537272244264288033276739579716599246665772965854249656943282002695659011960313245796587834222078633141747802754149848079632693280265262199729548775879612614113828267471629389698999657686858047585254549801752634049341009476489652456620836030696102393122618822021082792763848220677651608135328630551380537642144416978955966827336280510774254681264136102268730343853559751471313539810499170669215479225898738527316798768622089152851154959800113070358637984124299357803777453137311143202502153552192970732744885328421213081964363890280109214401691255867427694709196120824176729643585687319321473
e = 65537

W = 2**2024
M = Matrix(ZZ, [[x * W, 1, 0, 0],
                [a * W, 0, 1, 0],
                [k * W, 0, 0, W]])
M = M.LLL()

for row in M.rows():
    if row[-1 ] == W:
        p = abs(row[2])
        q = n // p
        phi = (p - 1) * (q - 1)
        d = inverse(e, phi)
        m = pow(c, d, n)
        print(long_to_bytes(m))

# L3AK{u_4ctu4lly_pwn3d_LLL_w1th_sh0rt_v3ct0rs_n1c3}
```

## Shiro Hero
Source code:
[ecc.py](https://ray.so/ojXeS8P)
[prng.py](https://ray.so/ho9QBDB)
```python
from secrets import randbits
from prng import xorshiro256
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from ecc import ECDSA
from Crypto.Util.number import bytes_to_long, long_to_bytes
import hashlib
flag = open("flag.txt", "rb").read()
state = [randbits(64) for _ in range(4)]
prng = xorshiro256(state)
leaks = [prng.next_raw() for _ in range(4)]
print(f"PRNG leaks: {[hex(x) for x in leaks]}")
Apriv, Apub = ECDSA.gen_keypair()
print(f"public_key = {Apub}")
msg = b"My favorite number is 0x69. I'm a hero in your mother's bedroom, I'm a hero in your father's eyes. What am I?"
H = bytes_to_long(msg)
sig = ECDSA.ecdsa_sign(H, Apriv, prng)
print(f"Message = {msg}")
print(f"Hash = {H}")
print(f"r, s = {sig}")
key = hashlib.sha256(long_to_bytes(Apriv)).digest()
iv = randbits(128).to_bytes(16, "big")
cipher = AES.new(key, AES.MODE_CBC, iv)
ciphertext = iv.hex() + cipher.encrypt(pad(flag, 16)).hex()
print(f"ciphertext = {ciphertext}")
with open("output.txt", "w") as f:
    f.write(f"PRNG leaks: {[hex(x) for x in leaks]}\n")
    f.write(f"public_key = {Apub}\n")
    f.write(f"Message = {msg}\n")
    f.write(f"Hash = {H}\n")
    f.write(f"r, s = {sig}\n")
    f.write(f"ciphertext = {ciphertext}\n")
```
Ta thấy rằng, `nonce` trong phần `ecdsa_sign` được tính dựa trên `prng()`. Và ta đã được cung cấp 4 output liên tiếp của `prng`. Vì tất cả các phép biến đổi trong `next_raw()` đều chỉ là phép xor và dịch bit nên ta có thể biểu diễn chúng thành các phương trình toán học và dùng `Z3` để tìm lại 4 trạng thái ban đầu `s0, s1, s2, s3`.

Sau khi tìm được state ban đầu rồi thì ta tiếp tục sinh ra 4 state tiếp theo, sau đó ta sẽ tìm được `k`.

$$
s = k^{-1}*(h + dr) \pmod p \\
\Rightarrow d = r^{-1}*(sk-h) \pmod p
$$

Thay số và phương trình và tìm được `d`. Sau đó giải mã AES-CBC để lấy `FLAG`.

Code:
```python
from z3 import *

MASK64 = (1 << 64) - 1

def rotl(x, k):
    return ((x << k) | LShR(x, 64 - k)) & MASK64

leaks = [0x785a1cb672480875, 0x91c1748fec1dd008, 0x5c52ec3a5931f942, 0xac4a414750cd93d7]

s0 = BitVec('s0', 64)
s1 = BitVec('s1', 64)
s2 = BitVec('s2', 64)
s3 = BitVec('s3', 64)

def next_raw(state):
    s0, s1, s2, s3 = state
    t = (s1 << 17) & MASK64

    s2 ^= s0
    s3 ^= s1
    s1 ^= s2
    s0 ^= s3
    s2 ^= t
    s3 = rotl(s3, 45)

    return s1, [s0, s1, s2, s3]

solver = Solver()
state = [s0, s1, s2, s3]

for i in range(4):
    out, state = next_raw(state)
    solver.add(out == leaks[i])

if solver.check() == sat:
    model = solver.model()
    recovered = [model[v].as_long() for v in [s0, s1, s2, s3]]
    print("Found state:", recovered)

from secrets import randbits
from prng import xorshiro256
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from ecc import ECDSA
from Crypto.Util.number import bytes_to_long, long_to_bytes
from Crypto.Util.number import *
import hashlib

state = [4632343889369999961, 10793220881798324403, 12527397580889080479, 11809022490152434257]
prng = xorshiro256(state)
leaks = [prng.next_raw() for _ in range(4)]
print(f"PRNG leaks: {[hex(x) for x in leaks]}")
k = prng()
r, s = (54809455810753652852551513610089439557885757561953942958061085530360106094036, 42603888460883531054964904523904896098962762092412438324944171394799397690539)
h = 9529442011748664341738996529750340456157809966093480864347661556347262857832209689182090159309916943522134394915152900655982067042469766622239675961581701969877932734729317939525310618663767439074719450934795911313281256406574646718593855471365539861693353445695
d = inverse(r, ECDSA.n) * (s * k - h) % ECDSA.n

key = hashlib.sha256(long_to_bytes(d)).digest()
ciphertext = '404e9a7bbdac8d3912d881914ab2bdb924d85338fbd1a6d62a88d793b4b9438400489766e8e9fb157c961075ad4421fc'
iv = bytes.fromhex(ciphertext[:32])
ciphertext = bytes.fromhex(ciphertext[32:])
cipher = AES.new(key, AES.MODE_CBC, iv)
flag = cipher.decrypt(ciphertext)
print(flag)

# L3AK{u_4r3_th3_sh1r0_h3r0!}
```

## Dumber
Source code:
```python
from Crypto.Util.number import  bytes_to_long, long_to_bytes
from sage.all import *

a,b,p = ?,?,?

pt1="L3AK{test_"
pt2="flag}"

E = EllipticCurve(Zmod(p), [a, b])
p,q=E.random_element(),E.random_element()
u=bytes_to_long(pt1.encode())*p
v=bytes_to_long(pt2.encode())*q

# I will help u <3
print(p,u,q,v)


# (103905521866731574234430443362297034336 : 116589269353056499566212456950780999584 : 1)
# (171660318017081135625337806416866746485 : 122407097490400018041253306369079974706 : 1)
# (161940138185633513360673631821653803879 : 167867902631659599239485617419980253311 : 1)
# (95406403280474692216804281695624776780 : 109560844064302254814641159241201048462 : 1)
```
Để giải quyết bài này, việc đầu tiên phải làm đó là khôi phục lại các hệ số của đường cong Elliptic `a, b, p`. Ta đã được cho 4 điểm nằm trên đường cong nên chúng thỏa mãn:

$$
y_i^2 = x_i^3+ax_i+b \pmod p \\
\Rightarrow y_i^2 - x_i^3 = ax_i + b \pmod p \\
\Rightarrow A_i := y_i^2-x_i^3 = ax_i+b \pmod p
$$

Vì $a, b$ là các hằng số nên ta có hệ 4 phương trình tuyến tính theo $a, b$ modulo $p$:

$$
\begin{cases}
A_1 = ax_1 + b \pmod p \\
A_2 = ax_2 + b \pmod p \\
A_3 = ax_3 + b \pmod p \\
A_4 = ax_4 + b \pmod p \\
\end{cases}
$$

Nếu trừ 2 phương trình bất kì cho nhau thì sẽ triệt tiêu được $b$, khi đó:

$$
A_i - A_j \equiv a(x_i - x_j) \pmod p \\
\Rightarrow a \equiv \frac{A_i-A_j}{x_i-x_j} \pmod p \\
\Rightarrow \frac{A_i-A_j}{x_i-x_j} \equiv \frac{A_k-A_l}{x_k-x_l} \pmod p \\
\Rightarrow (A_i-A_j)(x_k-x_l) \equiv (A_k-A_l)(x_i-x_j) \pmod p \\
\Rightarrow (A_i-A_j)(x_k-x_l) - (A_k-A_l)(x_i-x_j) \equiv 0 \pmod p \\
$$

Vậy, với mỗi hoán vị của 4 điểm trên, ta sẽ tính được một giá trị mà nó đồng dư với $0$ modulo $p$. Khi đó, chỉ cần lấy $GCD$ của các giá trị đó là ta sẽ tìm được $p$.

Ta có:

$$
\begin{cases}
y_P^2 \equiv x_P^3+ax_P+b \pmod p \\
y_Q^2 \equiv x_Q^3+ax_Q+b \pmod p
\end{cases}
$$

 Trừ phương trình trên cho phương trình dưới ta được:

$$
y_P^2-y_Q^2 \equiv x_P^3-x_Q^3 + a(x_P - x_Q) \pmod p \\
\Rightarrow a \equiv \frac{y_P^2-y_Q^2-(x_P^3 - x_Q^3)}{x_P-x_Q} \pmod p \\
\Rightarrow b \equiv y_P^2 - x_P^3 - ax_P \pmod p
$$

Như vậy ta đã khôi phục lại được đường cong $E$ ban đầu. Mình kiểm tra thử thì nhận thấy `order` của cả 2 điểm $P, Q$ đều bằng $p$. Tức là đây là **đường cong dị thường**. Sử dụng `Smart attack` để giải.

```python
from sage.all import *
from Crypto.Util.number import *
from itertools import *

P = (103905521866731574234430443362297034336, 116589269353056499566212456950780999584)
U = (171660318017081135625337806416866746485, 122407097490400018041253306369079974706)
Q = (161940138185633513360673631821653803879, 167867902631659599239485617419980253311)
V = (95406403280474692216804281695624776780, 109560844064302254814641159241201048462)

points = [P, U, Q, V]
A = [point[1]**2 - point[0]**3 for point in points]
res = []
for i, j, k, l in permutations([0, 1, 2, 3]):
    res.append((A[i] - A[j]) * (points[k][0] - points[l][0]) - (A[k] - A[l]) * (points[i][0] - points[j][0]))
p = gcd(res)

a = (P[1]**2 - Q[1]**2 - (P[0]**3 - Q[0]**3)) * pow(P[0] - Q[0], -1, p) % p
b = (P[1]**2 - P[0]**3 - a*P[0]) % p

E = EllipticCurve(GF(p), [a, b])
P, U, Q, V = [E(point) for point in points]

assert P.order() == p and Q.order() == p

def _lift(E, P, gf):
    x, y = map(ZZ, P.xy())
    for point_ in E.lift_x(x, all=True):
        _, y_ = map(gf, point_.xy())
        if y == y_:
            return point_
def attack(G, P):
    E = G.curve()
    gf = E.base_ring()
    p = gf.order()
    assert E.trace_of_frobenius() == 1, f"Curve should have trace of Frobenius = 1."

    E = EllipticCurve(Qp(p), [int(a) + p * ZZ.random_element(1, p) for a in E.a_invariants()])
    G = p * _lift(E, G, gf)
    P = p * _lift(E, P, gf)
    Gx, Gy = G.xy()
    Px, Py = P.xy()
    return int(gf((Px / Py) / (Gx / Gy)))

nA = attack(P, U)
nB = attack(Q, V)

print(long_to_bytes(nA).decode(), long_to_bytes(nB).decode())

# L3AK{5m4rt1_1n_ Th3_h00000d!!!}
```



## Continue ...